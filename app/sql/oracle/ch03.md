3. 오라클 성능 관리
- SQL 튜닝 과정
    쿼리성능문제 > Explain Plan 실행계획 확인 -> 문제점 파악 필요시 AutoTrace로 수행시 실제 일량 / SQL 트레이스로 내부수행 절차상 부하 원인확인 > 문제점 파악시 쿼리 변환/옵티마이저 흰트 사용해 튜닝 > 인덱스 조정 > 반정규화/집계테이블


01. Explain plan
- utlxplan.sql : plan_table 생성 (10g 부턴 오라클 설치시 기본적으로 해당 테이블 생성 - 사용자가 별도로 생성 필요 X)
- explain plan for : 해당 SQL에 대한 실행계획을 plan_table 에 저장
- utlxpls/utlxplp(parellel - 병렬정보) : plan table에서 읽은 데이터를 포맷팅 해주는 명령어


02. AutoTrace
- SQL 튜닝하는데 필요한 정보들을 포함
- 쿼리 수행결과 / 실행계획 / 실행통계
- set autotrace on (explain/statistics) / set autotrace traceonly (explain/statistics)
- 실행통계 확인 시 뷰(v_$sesstat(개별 세션 뷰)/v_$statname/v_$mystat(현재 접속한 본인 세션에 대한 수행통계)) 권한 필요
    > plustrce.sql로 롤 생성 > grant plustrce to scott;
- 실행 통계 항목별 분류
    - rows processed: sql로 처리된 총 횟수 (select된 로우 수)
    - elapsed time : 쿼리 수행시간
    ① I/O 관련
    db block gets	현재 트랜잭션이 수정한 블록을 읽는 횟수 (커밋되지 않은 변경 포함)
    consistent gets	Undo를 포함한 일관된 블록 읽기
    physical reads	버퍼 캐시에 없어서 디스크에서 직접 읽은 블록 수

    ② Redo & 처리량
    redo size	Redo 로그 생성량 (바이트)
    rows processed	처리된 행 수

    ③ 네트워크 관련
    bytes sent/received via SQL*Net	클라이언트와 주고받은 데이터 총량
    SQL*Net roundtrips	클라이언트와의 통신 횟수

    ④ 파싱 관련
    parse count (total)	SQL 파싱 총 횟수
    parse count (hard)	실행 계획까지 새로 짠 횟수 (하드 파싱)
    recursive calls	Oracle 내부적으로 자동 발생한 SQL (예: data dictionary access 등)

    ⑤ 정렬 관련
    sorts (memory)	메모리에서 완료된 정렬
    sorts (disk)	디스크로 spill-over된 정렬

03. SQL 트레이스
- SQL 튜닝할 때 가장 많이 사용하는 도구
- 1) 자기 세션에 트레이스 걸기 > alter session set sql_trace=true;
        읽기 권한 > alter session set tracefile_identifier='' > 파일 뒤쪽에 식별자 붙음
    - TKProf(Trace Kernel Profile) 유틸리티
        trc(트레이스) 파일을 읽기쉽게 포맷팅
    - prf로 확인할 수 있는 정보
        1) call: Parse Execute Fetch 에 대한 통계정보를 보여줌
        2) count: call의 각 단계가 수행된 횟수(fetch count = SQL*Net roundtrips)
        3) cpu: 현재 커서가 사용한 cpu time
        4) elapsed: 현재 커서가 각 단계를 수행하는데 소요된 시간
        5) disk: 디스크에서 읽은 블록 수(physical reads)
        6) current: current 모드에서 읽은 블록 수 (db block gets)
        7) query: Consistent 모드에서 읽은 블록 수 (consistent gets)
        8) rows: 각 단계에서 읽거나 갱신한 처리 건수 (fetch rows = rows processed)
    - cr(consistent row), pr(physical read), pw(physical write), time
    - 부모는 자식노듸의 값에 더해진 값
    - 이벤트 트레이스: 레벨 설정을 통해 바인드 변수와 대기 이벤트 발생 현황까지 수집 가능
        - alter session set events '10046 trace name context forever, level 1(4,8,12,off)';
        - 1, 4, 8, 12 레벨 
            1 > 일반적인 SQL 트레이스
            4, 8 > 바인드 변수에 대한 정보 확인
            12 > SQL 수행 도중 발생하는 이벤트 모두 로그처럼 기록
    - Elapsed tiem = cpu time + wait time = Response 시점 - call 시점
        SQL*Net message from client : App, Networt 구간에서 소모된 시간
        SQL*Net message to client : IDE 이벤트(클라이언트에게 메세지를 보냈는데 너무 바쁘거나 네트워크 부하 시)
        SQL*Net more data to client: 클라이언트에 전송할 데이터가 남았는데 네트워크 부하 때문에 바로 전송하지 못하는 대기 이벤트
        db file sequential read : single block read 방식 디그크 읽는 대기 이벤트
- 2) 다른 세션에 트레이스 걸기
    - 9i: exec dbms_system.set_ev(tptus, serial number, 10046이벤트 트레이스, 레벨(0일때 트레이스 해제), '');
    - 10g 이후: begin dbms_monitor.session_trace_enable(disable)
    - 공용: oradebug setospid ~
    - 시스템: alter system set sql_trace=true
- 3) Service, Module, Action 단위로 트레이스 걸기
    - dbms_monitor.serv_mod_act_trace_enable

04. DBMS_XPLAN 패키지
- 1) 예상된 실행계획 출력: plan_table에 저장된 실행계획을 더 쉽게 출력할 수 있음
    - select plan_table_output from table(dbms_xplan.display('plan_table',null,''));
        plan table명/statement_id(null이면 가장 마지막 explain plan 쿼리 실행계획)/다양한 포맷 옵션
            - basic : ID, OPERATION, NAME
            - ALL : 모든 항목 출력
            - ADBANVED: all+outline(같은 실행계획을 수립하는데 필요한 힌트)
- 2) 캐생된 커서의 실제 실행계획 출력
    - 커서란? 하드 파싱 과정을 거쳐 메모리에 적재된 SQL, Parse Tree, 실행계획, SQL Area
    - v$sql 뷰: 라이브러리 캐시에 캐싱된 각 커서에 대한 수행통계 볼 수 있음
    - v$sql_plan: 실제 수행하면서 사용했던 실행계획 확인 가능
        - 마지막 수행한 sql_id와 child_number값 알아야함.
        - ! 쿼리 수행 전 set serveroutput off 설정 필요! 
        - dbms_xplan.display_cursor(sql_id, child_number, 포맷옵션)
            : display 함수에는 없던 iostats, memstats, allstats 옵션 사용시 실제 수행시 Row Source 별 수행통계 보여줌
                - E: Expected (예상한) / A: Actual (실제)
                - 옵티마이저의 로우수를 비교해주면서 행동을 관찰할 때 유용하게 사용
                - 기본적으로 누적 값, 포맷 옵션에 last를 추가해주면 마지막 수행했을 때 일량 보여줌 (ex. ALLSTATS LAST)
        - dbms_xplan.display_awr : AWR에 수집된 과거 SQL에 대해서 같은 분석작업 진행 가능
    - v$sql_statistics: 마지막 수행 통계치/누적 통계치 컬럼 두개씩 제공
    - v$sql_plan_statistics_all(v$sql_plan+v$sql_statistics)
- 3) 캐싱된 커서의 Row Source별 수행 통계 출력
    - 실제 SQL을 수행하는 동안의 실행계획 각 오퍼레이션 단계별로 수행 통계 수집 방법
        1) gather_plan_statistics 힌트 사용
        2) 시스템/세션 레벨에서 statistics_level 파라미터를 all 로 설정
        3) '_rowsource_execution_statistics' 파라미터를 true 설정
        4) SQL 트레이스 걸기
    - 조회 방법: v$sql_statistics나 v$sql_plan_statistics_all 뷰 사용


05. V$SYSSTAT
- 인스턴스 기동 후 현재까지 누적된 수행 통계치를 시스템 레벨로 확인하고 싶을 때 
- 1) 시스템 수행 통계 수집 및 분석
    - 별도의 세션을 이용하는 이유: v$sesstat 을 조회해 insert할 때의 통계치가 섞이는 것을 방지
- 2) Ratio 기반 성능 분석: 주로 공유 리소스 사용빈도와 경합 발생 비율을 점검
    1)
    2)
    3)
    4)
    5)
    6)
    7)
    8)
    9)
    10)
    11)
    12)
    13)


06. V$SYSTEM_EVENT

07. Response Time Analysis 방법론과 OWI

08. Statspack / AWR

09. ASH(Active Session History)

10. V$SAL

11. End-To-End 성능 관리

12. 데이터베이스 성능 고도화 정성 해법