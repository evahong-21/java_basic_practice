
04. Redo
- "오라클"은 데이터파일과 컨트롤파일에 가해지는 모든 변경사항을 하나의 Redo 로그 앤트리로서 Redo 로그에 기록
- Online Redo와 Archived(Offline) Redo로 구성
    1) Online Redo: Redo 로그 버퍼에 버퍼링된 로그 엔트리를 기록하는 파일 -> 최소 두개 이상의 파일로 구성
        로그 스위칭: 현재 사용중인 redo 로그 파일이 꽉 차면 다음 로그파일로 로그 스위칭
        라운드 로빈: 모든 redo 로그 파일이 꽉 차면 다시 첫 번째 redo 로그 파일부터 재사용
    2) Archived Redo: 온라인 redo 로그가 재사용되기 전에 다른 위치로 백업해 둔 파일
- 3가지 목적을 위해 사용
    1) Database Recovery: 물리적으로 디스크가 깨지는 등의 Media Fail 발생 시 복구에 사용 -> Archived Redo 사용
    2) Cache(Instance) Recovery: 
        모든 디비 시스템이 버퍼 캐시를 도입 -> I/O 성능 향상 -> 버퍼캐시는 휘발성
        정전 등으로 시스템 재가동시 Online Redo 로그에 저장된 기록을 읽어 마지막 체크포인트 이후부터 트랜잭션을 재현
        > 버퍼 캐시에만 수정하고 데이터파일에 반영되지 않았던 변경사항들 복구 -> 트랜잭션의 커밋여부를 불문하고 일단 직전 상태로 되돌리는게 목표
        - DBWR가 Dirty버퍼를 데이터 파일에 기록하기 전에 로그 버퍼를 먼저 Redo 로그에 기록 
            >Redo 로그에 없는 변경 내용이 이미 데이터 파일에 기록되어 있으면 최종 커밋하지 않은 트렌젝션이 커밋됨
    3) Fast Commit: 트랜잭션 발생시 건건이 데이터파일에 기록하는게 아닌 우선 append방식으로 빠르게 로그파일에 기록
            -> 메모리 데이터 블록과 데이터 파일간 동기화는 적절한수단(DBWR, Checkpoint) 를 이용해 나중에 배치 방식으로 일괄 수행.
        변경된 메모리 버퍼 블록을 디스크상의 데이터블록에 기록하는 작업은 random액세스 방식으로 느림
        > 로그는 append 방식으로 기록하므로 빠름
        - Delayed 블록 클린아웃: 오라클만의 특징
            블록 클린아웃: 갱신된 블록에 커밋 정보를 기록하고 lock을 해제하는 작업
            별도의 lock 매니저 없이 로우 락을 구현해서 락을 해제하려면 갱신한 블록을 일일이 찾아야해서 느림
            커밋 시점에는 Undo 세그먼트 헤더의 트랜잭션 테이블에만 커밋정보 기록 > 블록 클린아웃은 나중에 수행
        - 사용자가 커밋을 날리면 > 서버 프로세스는 커밋 레코드를 redo 로그 버퍼에 기록 > LGWR는 즉시 트랜잭션 로그 앤트리와 함께 redo 파일에 저장 > 커밋을 수해한 서버 프로세스에 success code 리턴
        - log file sync 대기 이벤트 : LGWR가 로그 버퍼 내용을 로그파일에 기록할 때까지 서버 프로세스가 대기하는 현상
- Redo 레코드 기록 : 곧바로 로그 파일에 저장하는것이 아닌 먼저 로그 버퍼에 기록
    > 데이터 블록 버퍼를 변경하기 전 항상 Redo 로그 버퍼에 먼저 기록 > 일정 시점마다 LGWR에 의해 버퍼에서 파일에 기록
- LGWR : Redo 로그 버퍼를 로그에 기록하는 시점
    1) 3초마다 DBWR 프로세스로부터 신호 받을 때
    2) 로그 버퍼의 1/3이 차거나 기록된 Redo 레코드량이 1MB를 넘길때
    3) 사용자가 커밋 또는 롤백 명령을 날릴떄

05. Undo
- 과거에는 롤백이라는 용어 주로 사용 -> 9i부터 오라클은 공식적으로 Undo 용어 사용
- 8i: 롤백 세그먼트를 생성, 온라인/오프라인 상태변경을 관리자가 직접 수행&대용량 트랜잭션 처리를 위해 사용할 롤백 세그먼트를 가끔 수동으로 변경
- AUM(automatic undo management) 도입(9i)
- 일반 테이블 세그먼트와 기능 동일: 익스텐트 단위로 확장 > 빠른 I/O를 위해 undo블록들을 버퍼 캐시에 캐싱 > 데이터 유실을 방지하기 위해 변경사항을 Redo 로그에 로깅
    - 다른점: 저장하는 내용.
- Automatic Undo Management : Undo 세그먼트마다 하나의 트랜잭션이 할당되는 것을 목표 -> 세그먼트 개수를 오라클이 자동 관리
    : 트랜잭션에 독립적으로 할당해 줄 Undo 세그먼트가 없을 떈(온라인으로 전환할 수 있는 오프라인 세그먼트가 없고 새로운 Undo 세그먼트를 생성할 공간도 부족할 때) 가장 적게 사용되는 Undo 세그먼트 중 하나 할당
- 저장된 정보의 목적
    1) Transaction Rollback: 트랜잭션에 의한 변경사항을 커밋하지 않고 롤백하고자 할 때
    2) Transaction Recovery(Instance Recovery시 rollback 단계): 
        인스턴스 크러시 발생 후 Redo를 이용해 Roll forward 단계가 완료되면 최종 커밋되지 않았던 변경사항까지 모두 복구. 
        시스템이 셧다운 된 시점에 아직 커밋되지 않았던 트랜잭션을 모두 롤백하는데 저장된 데이터 사용
    3) Read Consistency(읽기 일관성): DB2, SQL Server, Sybase 는 Lock을 통해 읽기 일관성 구현
        오라클은 Undo 데이터를 이용해 읽기 일관성을 구현
- Undo 세그먼트 트랜잭션 테이블 슬롯
    - Undo 세그먼트의 첫번째 익스텐트의 첫번째 블록은 세그먼트의 헤더 정보가 담겨져 있음 -> Undo Header
    - Undo 세그먼트 헤더 : 트랜잭션 테이블 슬록 위치
        1) 트랜잭션 ID: USN(undo segment number) + Slot + Wrap
            슬롯을 바로 얻지 못해 발생하는 대기 이벤트 -> Undo segment tx slot
            이제 트랜잭션이 발생시키는 데이터 또는 인덱스 블록에 대한 변경사항은 Undo 블록에 Undo 레코드로 하나씩 차례대로 기록
                (Insert: 추가된 레코드 rowid/Update: 변경되는 컬럼의 before Image/Delete: 지운 로우의 모든 컬럼에 대한 before image)
        2) 트랜잭션 상태정보
            트랜잭션 시작하려면 Undo 세그먼트에 있는 트랜잭션 테이블에서 슬롯을 할당 받아야 함-> Active 상태 표시 후 갱신
            아직 커밋되지 않은 Active상태의 트랜잭션이 사용하는 Undo 블록과 트랜잭션 테이블 슬록은 절대 다른 트랜잭션에 의해 재사용 X
        3) 커밋 SCN(트랜잭션이 커밋된 경우)
            상태정보를 'committed'로 변경 -> 다른 트랜잭션에 재사용 가능
            가장 먼저 커밋된 트랜잭션 슬롯부터 순차적으로 재사용 되므로 Undo 데이터는 커밋 후에도 상당기간 남아있음
        4) Last UBA(Undo block address)
            기록사항을 가장 마지막 Undo 레코드 뒤에 계속 추가하려고 유지하는 일종의 포인터
            각 레코드는 체인으로 연결되어 롤백할 때 거슬러 올라가 작업 수행
            v$transaction 뷰의 used_ublk, used_urec 컬럼으로 현재 사용중인 Undo 블록 개수와 현재까지 기록한 레코드 양 확인
            update는 두개의 Undo 레코드 추가(delete 후 insert하기 때문)
        5) 기타
- Undo Retention (무슨 내용인지?)
    - AUM이 도입되면서 새롭게 생긴 파라미터 : undo_retention -> 트랜잭션이 완료되도 지정한 시간동안은 가급적 Undo 데이터 재사용 X
    - retention guarantee: Undo 테이블 스페이스에 옵션 설정 -> 공간이 부족해 에러를 발생해도 undo_retention으로 지정된 시간 이내에 커밋된 Undo 정보는 재사용하지 않는다.
    - Automatic Undo Retention Tuning: tuned_undo_retention 값 자동 관리 -> Undo Extent의 상태정보 관리
- 블록 헤더 ITL 슬롯
    - Interested Transaction List 슬롯: 각 데이터 블록/인덱스 블록 헤더에 존재
        1) ITL 슬롯 번호
        2) 트랜잭션 ID
        3) UBA
        4) 커밋 Flag
        5) Locking 정보
        6) 커밋 SCN
    - ITL 슬롯 부족으로 트랜잭션 블로킹 최소화 하기 위해 3가지 옵션 제공
        1) initrans: 블록을 사용하려고 처음 포맷할 때 블록 헤더에 ITL슬롯을 몇개 할당할지 결정하는 파라미터
        2) maxtrans: 블록헤더에 미리 할당해둔 ITL슬롯이 모두 사용중이면 개수만큼 데이터 영역에 추가 ITL슬롯을 할당 하게 함
        3) pctfree: 예약된 여분의 공간
    - ITL 슬롯이 부족할 때 발생하는 대기 이벤트: enq: TX-allocate ITL entry
- Lock Byte
    - 레코드가 저장되는 로우마다 그 헤더에 Lock Byte를 할당해 해당 로우를 갱신중인 트랜잭션의 ITL슬롯 번호를 기록 -> row-level Lock
    - 오라클의 로우 Lock : 로우단위 Lock과 트랜잭션 Lock 을 조합
    - 레코드 갱신 > 대상 래코드의 Lock Byte가 활성화 되어있다 > ITL 슬롯 찾아간다 > ITL 슬롯이 가리키는 트랜잭션 테이블 슬롯 > 
        트랜잭션이 아직 active다 > 트랜잭션이 완료될 때까지 대기

11. Shared Pool
- SGA의 가장 중요한 구성요소 중 하나
- 1) 딕셔너리 캐시
    - 오라클 딕셔너리 정보를 저장해 두는 캐시영역
    - Row 단위로 읽고 쓰기 때문에 로우캐시(row cache) 라고 불림
    - 테이블, 인덱스, 데이터베이스, 데이터파일, 세그먼트, 익스텐트, 사용자, 제약, Sequence, DB Link 에 관한 정보를 캐싱
    - Sequence Cache 옵션 : 잦은 채번은 로우 캐시에 경합을 발생시키므로 사용해야함
    - v$rowcache: 히트율을 조사했을 떄 수치가 낮게 나오면 Shared pool 사이즈를 늘려야함
    - 로우 캐시에 관리되는 엔트리 각각에 대해 하나의 래치가 할당돼 있음
- 2) 라이브러리 캐시 
    - 사용자가 던진 SQL 과 그 실행계획을 저장해 두는 캐시영역
    - 실행계획 : 빠른 쿼리 수행을 위해 내부적으로 생성한 일종의 프로시저
    - 하드파싱 : 쿼리 구문 분석 > 문법 오류 및 실행권한 체크 > 최적화 과정으로 실행 계획 생성 > SQL실행엔진이 이해할 수 있는 형태로 포맷팅 하는 전 과정
    - 하드 파싱을 최소화 하기 위해 새로운 캐시 공간이 바로 라이브러리 캐시 영역 -> 캐싱된 SQL과 그 실행계획의 재사용성을 높이기 위함