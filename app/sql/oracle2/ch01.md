# Chapter 01 인덱스 원리화 활용
- 인덱스는 대용량 테이블에서 필요한 데이터만 빠르고 효율적으로 액세스할 목적으로 사용하는 오브젝트
- 키:컬럼 순으로 정렬

## 1. 인덱스 구조
### 1.1 범위 스캔
    - 특정 위치에서 스캔시작 검색조건에 일치하지 않는 값을 만나는 순간 중지하는 것
    - IOT(Index-Organized Table): 테이블 범위 스캔 > 특정 컬럼순으로 정렬상태 유지 
        > 일반적인 힙 구조 테이블(Heap-organized table)에서 범위 스캔은 있을 수 없음

### 1.2 인덱스 기본 구조
    - B*tree 인덱스 구조: 가장 일반적으로 사용되는 인덱스
    - 브랜치 블록(루트 포함): 하위 노드 블록을 찾아가기 위한 DBA(Data Block Address)정도 갖음
        - 키 값과 하위 노드를 가리키는 블록 주소를 갖음
            - 키 값은 자식 노드가 갖는 값의 범위.
        - LMC(LeftMost Child): 유일하게 키 값이 없음, 브랜치 노드의 첫번째 엔트리
            - 키 값을 가진 첫번째 엔트리보다 작은 값 > 브랜치 블록의 자식 노드 중 가장 왼쪽 끝에 위치
    - 최말단 리프: 인덱스 키 컬럼, 해당 테이블 레코드를 찾아가기 위한 주소정보(ROWID)를 갖음
        > 항상 키 컬럼 순으로 정렬 > 범위스캔 가능
        - 키 값이 같을 땐 rowid 순으로 정렬
    - 인덱스와 테이블 레코드 간엔 1:1 대응 관계
        - 테이블 레코드에서 값이 생긴되면 리프노드 인덱스 키 값도 갱신(delete&insert)
            > 리프 노드상 엔트리 키 값이 갱신되어도 브랜치 노드까지 바뀌진 X
        - 클러스터 인덱스(Cluster Index): 1:M 관계
        -브랜치 노드의 갱신: 인덱스 분할(Split)에 의해 새로운 블록이 추가되거나 삭제(다른 브랜치의 자식 노드로 이동)될 때
    정리!! 
        1) 리프 노드상의 인덱스 레코드와 테이블 레코드 간에 1:1
        2) 리프 노드상의 키 값과 테이블 레코드 키 값은 서로 일치
        3) 브랜치 노드상의 레코드 개수는 하위 레벨 블록 개수와 일치
        4) 브랜치 노드상의 키 값은 하위 노드가 값는 값의 범위를 의미

### 1.3 인덱스 탐색
    1) 수직적 탐색
        - 수평적 탐색을 위한 시작 지점을 찾는 과정: 루트에서 리프블록까지 아래쪽으로 진행
    2) 수평적 탐색
        - 범위 스캔
        - 리프 블록을 인덱스 레코드 간 논리적 순서에 짜라 좌우,우좌로 스캔
    - 결합 인덱스 구조와 탐색

### 1.4 ROWID 포맷
    - 데이터 파일 번호, 블록 번호, 로우 번호: 테이블 레코드의 물리적 위치정보를 포함
    - pseudo 컬럼: rowid값이 테이블에 실제 저장되지는 않음
    - 6 byte: 
        - 파티션 되지 않은 일반 테이블에 생성한 인덱스
        - 파티션 된 테이블에생성한 로컬 파티션 인덱스
    - 10 byte
        - 파티션 테이블에 생성한 글로벌 파티션 인덱스
        - 파티션 테이블에 생성한 비파티션 인덱스
    - 제한된 rowid 포맷 : 데이터파일번호(4자리) + 블록 번호(8자리) + 로우 번호(4자리) -> 16자리 + . 2자 -> 18
        - 데이터파일번호: 로우가 속한 데이터파일 번호, 데이터베이스 내 유일한 값
        - 블록번호: 해당 로우가 저장된 데이터 블록 번호, 데이터파일 내의 상대적 번호
        - 로우번호: 블록 내에서 각 로우에 붙여진 일련번호, 0부터 시작
        - 순서: 블록.로우.데이터파일
    - 확장 rowid 포맷: 데이터오브젝트(6자리) + 데이터파일번호(3자리) + 블록번호(6자리) + 로우번호(3자리) -> 18
    - dbms_rowid 패키지: 각 구성요소 정보, 확장 rowid > 제한 rowid 포맷으로 변경
        - rowid_to_restricted, rowid_object(ri), rowid_relative_fno(ri), rowid_block_number(ri), rowid_row_number(ri), rowid_type


## 2. 인덱스 기본 원리
- B*tree 인덱스를 제대로 사용하려면 범위 스캔 가능 > 인덱스 선두 컬럼이 조건절에 사용되지 않으면 범위스캔 불가
    > 인덱스 선두 컬럼이 조건절에 사용되더라도 인덱스사용불가/범위스캔불가 가능성 있음

### 2.1 인덱스 사용이 불가능하거나 범위 스캔이 불가능한 경우 
    - 인덱스 범위 스캔 불가: 조건절에 가공한 인덱스 컬럼을 사용/부정형비교<>,is not nul
    - 오라클은 단일 컬럼 인덱스에 null 값은 저장하지 않음
        > 결합 인덱스는 인덱스 구성 컬럼중 하나라도 값이 Null이 아닌 레코드는 인덱스에 포함 > 필터링 가능
    - is null 조건 검색은 인덱스 사용 불가
        > but 인덱스 구성 컬럼에 이외의 조건식이 하나라도 있으면 Range Scan가능 (혹은 다른 구성컬럼이 Not Null 제약 이라면)
### 2.2 인덱스 컬럼의 가공
    - nvl(주문수량, 0) < 100
        - 주문수량이 NOT NULL 컬럼 : nvl 함수 제거하여 range scan 가능
            - NOT NULL 컬럼이 아니고 해당하는 건수가 아주 많다면 -> TABLE FULL SCAN 유리
                - 해당하는 건수가 적다면 함수기반 인덱스(FBI) 생성 고려
    - 튜닝사례 1
        - 지수구분코드 || 지수업종코드 in ('1001', '2003') -> (지수구분코드, 지수업종코드) in (('1','001'),('2','003'))
    - 튜닝사례 2
        - decode 문을 분석해 논리적으로 동일한 결과를 리턴하도록 인덱스 선두 컬럼에 가공 안되게 수정

### 2.3 묵시적 형변환
    - 숫자형과 문자형을 비교할 때 숫자형으로/문자형과 날짜형이 만나면 날짜형으로 > 명시적으로 변환함수를 사용하자!!!
        > 인덱스 컬럼과 비교되는 반대쪽을 인덱스 컬럼 데이터 타입에 맞춰주는게 이상적
    - 만약 묵시적 형변환이 일어난 컬럼이 조건절의 좌변이라면 가공이 되어 Range Scan 불가
    - Like 쓸 땐 숫자형도 문자형으로 변환
    - 사용시 주의사항
        decode(a,b,c,d) : a=b이면 c 아니면 d
            > 출력되는 타입은 C의 타입, 만약 c가 null이면 D는 varchar2 타입으로 형변환
            > d는 숫자인데 c가 null이면 varchar2로 취급하며 3000 vs 950 일 때 950으로 출력
    - 함수기반 인덱스(FBI) 활용
        - 묵시적 형변환으로 성능이슈가 발생 but 프로그램을 바꿀 만큼 시간적 여유가 없을 떄
        - ex) Create index emp_x01 on emp(to_number(v_deptno))


## 3. 다양한 인덱스 스캔방식
### 3.1 Index Range Scan
- 인덱스 루트블록 -> 리프 블록까지 수직적 탐색 -> 리프 블록을 필요한 범위만 스캔하는 방식
- B*tree인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식
- 인덱스를 구성하는 선두 컬럼이 조건절에 사용되어야 함 (꼭 = 일 필요는 X)
- 인덱스 컬럼 순으로 정렬되기 때문에 sort order by를 생략하거나 min/max 값을 빠르게 추출 가능
- Index (Range Scan)

### 3.2 Index Full Scan
- 수직적 탐색 없이 처음부터 끝까지 인덱스 리프 블록을 수평적으로 탐색
- 효용성
    - 인덱스 선두 컬럼이 조건절에 없다면 옵티마이저는 우선적으로 Table Full Scan을 고려
        > 이 상황에서 인덱스 스캔으로 대부분의 레코드를 필터링 하고 일부만 테이블액세스가 발생한다면 테이블풀스캔보다 성능 향상
        > 대용량 테이블이라면 Index Full Scan방식이 유용
- Index Range Scan 처럼 인덱스 컬럼 기준으로 정렬 -> sort order by 생략 가능
    - first_rows(n): n개만 먼저 읽고 노출 > 빠르게 리턴할 목적으로 방식 선택
- Index (Full Scan)

### 3.3 Index Unique Scan
- 수직적 탐색만드로 데이터를 찾는 스캔 방식
- Unique 인덱스를 통해 = 조건으로 탐색하는 경우
- Unique 컬럼이더라도 조건이 범위 검색 조건(between, 부등호, Like) 라면 Index Range Scan으로 수행
- Unique 결합 인덱스에 일부 컬럼만 검색할 떄에도 Index Range Scan으로 수행
    > ex. Index A, B, C / select where A, C
- Index (Unique Scan)

### 3.4 Index Skip Scan
- 인덱스 선두컬럼이 조건절로 사용되지 않으면 옵티마이저는 Table Full Scan하려고 함
    > Table Full Scan보다 Index Full Scan이 효율이 더 좋을 수 있음
    > 9i부턴 Index Skip Scan을 사용
- 조건절에 빠진 인덱스 선두 컬럼의 Distinct Value가 적고 후행 컬럼의 Distinct Value 개수가 많을 때 유용
- 루트 또는 브랜치 블록에서 읽은 컬럼값 정보를 이용해 조건에 부합하는 레코드를 포함할 가능성이 있는 리프 블록만 골라서 액세스
- 버퍼 Pinning을 이용한 Skip 원리
    - Skip Scan은 리프 블록에서 다시 위쪽 브랜치 블록을 재방문하여 다음 방문할 리프블록 주소 정보 필요
    - 루트 또는 브랜치에 재방문 하더라도 Pinning 상태이므로 추가적인 블록 I/O는 발생하지 X
- Index 컬럼이 3개일 때
    1) 최선두 컬럼은 조건절에 존재, 중간 컬럼에 대한 조건절이 누락된 경우
    2) Distinct Value 값이 적은 2개의 선두 컬럼 모두 누락된 경우
    3) 선두 컬럼이 범위검색 조건일 때도 사용 가능
- In-List Iterator 와 비교
    - Index Skip Scan에 의존 하지 않아도 결과집합을 얻을 수 있음 but in 종류가 적어야함
- index_ss, no_index_ss
- Index (Skip Scan)

### 3.5 Index Fast Full Scan
- Index Full Scan 보다 빠름
- 인덱스 트리구조를 무시하고 인덱스 세그먼트 전체를 Multiblock Read 방식 사용 함
- 논리적 구조가 아닌 물리적으로 디스크에 저장된 순서대로 read 
- 결과집합이 인덱스 키 순서대로 정렬되지 X
- 쿼리에 사용되는 모든 컬럼이 인덱스 컬럼에 포함되어야 함
- 인덱스가 파티션 되어있지 않아도 병렬처리 가능 > Direct Path Read 방식을 사용하므로 속도 향상
- 버퍼 캐시 히트율이 낮아 디스크 I/O가 많이 발생할 때 유리
- index_ffs, no_index_ffs
- INDEX (FAST FULL SCAN)

### 3.6 Index Range Scan Descending
- Index Range Scan과 기본적으로 동일
- 인덱스를 뒤에서 앞으로 읽으므로 정렬 결과가 Desc
- index_desc
- Index (Range SCAN DESCENDING)

### 3.7 And-Equal, Index Combine, Index Join
- 인덱스가 아무리 많아도 테이블 당 하나만 사용하는것이 일반적
- 오라클은 두 개 이상 인덱스 함께 사용 가능
1) And-Equal : Index Combine이 생기고 효용 X, 10g부턴 폐기
    - 단일 컬럼의 Non-Unique 인덱스 , 인덱스 컬럼에 대한 조건절 =
    - 단독으로 테이블 랜덤 액세스를 많이 발생 시키는 단일컬럼 인덱스를 두개이상 결합해 테이블 액세스량을 줄임
2) Index Combine
    - And-Equal과 같이 데이터 분포도가 좋지 않은 두개 이상의 인덱스를 결합해 테이블 랜덤 액세스를 줄이는데 목적
    - 조건절이 OR로 결합된 경우에도 유용
    - _b_tree_bitmap_plans 파리미터 true일 때 작동
3) Index Join
    - 한 테이블에 속한 여러 인덱스를 이용해 테이블 액세스 없이 결과집합 생성
    - 해시 조인 매커니즘 사용
    - 작동원리
        1) 크기가 비교적 작은 쪽 인덱스에서 키값과 rowid를 읽어 PGA메모리에 해시 맵 저장(해시맴의 키는 rowid)
        2) 다른 쪽 인덱스를 스캔하면서 앞서 생성한 해시 맵에 같은 Rowid값을 갖는 레코드가 있는지 탐색
        3) rowid끼리 조인에 성공한 레코드만 결과집합에 포함 > 각 인덱스 컬럼에 대한 검색조건을 모두 만족한다는 뜻이므로


## 4. 테이블 Random 액세스 부하
- 대량의 데이터를 처리할 때 테이블 Random 액세스가 가장 큰 부하요인

### 4.1 인덱스 ROWID에 의한 테이블 액세스
- 테이블 랜덤 액세스 : Table Access By Index ROWID
- ROWID: 데이터파일 번호 + 블록 번호 + 블록내 로우 번호 > 물리적 주소 같지만 논리적 주소
- 메인메모리 DB와 비교
    - 오라클은 디스크 상의 주소정보(DBA)를 담지만, 메인메모리는 메모리상의 주소정보 즉 포인터를 담는다 -> 액세스가 매우 빠름
    - 오라클은 테이블 블록이 수시로 버퍼 캐시에 밀려났다가 캐싱 -> 다른 공간에 캐싱되므로 직접 포인터로 연결 불가
    - 오라클은 해시 키로 DBA를 삼아 해싱 알고리즘으로 버퍼 블록 검색 -> 해시 버킷은 고정적
- 인덱스 rowid에 의한 테이블 액세스 구조

### 4.2


5. 테이블 Random 액세스 최소화 튜닝



6. IOT, 클러스터 테이블 활용



7. 인덱스 스캔 효율



8. 인덱스 설계



9. 비트맵 인덱스