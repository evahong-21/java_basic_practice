Chapter 01 인덱스 원리화 활용
- 인덱스는 대용량 테이블에서 필요한 데이터만 빠르고 효율적으로 액세스할 목적으로 사용하는 오브젝트
- 키:컬럼 순으로 정렬

1. 인덱스 구조
- 1) 범위 스캔
    - 특정 위치에서 스캔시작 검색조건에 일치하지 않는 값을 만나는 순간 중지하는 것
    - IOT(Index-Organized Table): 테이블 범위 스캔 > 특정 컬럼순으로 정렬상태 유지 
        > 일반적인 힙 구조 테이블(Heap-organized table)에서 범위 스캔은 있을 수 없음
- 2) 인덱스 기본 구조
    - B*tree 인덱스 구조: 가장 일반적으로 사용되는 인덱스
    - 브랜치 블록(루트 포함): 하위 노드 블록을 찾아가기 위한 DBA(Data Block Address)정도 갖음
        - 키 값과 하위 노드를 가리키는 블록 주소를 갖음
            - 키 값은 자식 노드가 갖는 값의 범위.
        - LMC(LeftMost Child): 유일하게 키 값이 없음, 브랜치 노드의 첫번째 엔트리
            - 키 값을 가진 첫번째 엔트리보다 작은 값 > 브랜치 블록의 자식 노드 중 가장 왼쪽 끝에 위치
    - 최말단 리프: 인덱스 키 컬럼, 해당 테이블 레코드를 찾아가기 위한 주소정보(ROWID)를 갖음
        > 항상 키 컬럼 순으로 정렬 > 범위스캔 가능
        - 키 값이 같을 땐 rowid 순으로 정렬
    - 인덱스와 테이블 레코드 간엔 1:1 대응 관계
        - 테이블 레코드에서 값이 생긴되면 리프노드 인덱스 키 값도 갱신(delete&insert)
            > 리프 노드상 엔트리 키 값이 갱신되어도 브랜치 노드까지 바뀌진 X
        - 클러스터 인덱스(Cluster Index): 1:M 관계
        -브랜치 노드의 갱신: 인덱스 분할(Split)에 의해 새로운 블록이 추가되거나 삭제(다른 브랜치의 자식 노드로 이동)될 때
    정리!! 
        1) 리프 노드상의 인덱스 레코드와 테이블 레코드 간에 1:1
        2) 리프 노드상의 키 값과 테이블 레코드 키 값은 서로 일치
        3) 브랜치 노드상의 레코드 개수는 하위 레벨 블록 개수와 일치
        4) 브랜치 노드상의 키 값은 하위 노드가 값는 값의 범위를 의미
- 3) 인덱스 탐색
    1) 수직적 탐색
        - 수평적 탐색을 위한 시작 지점을 찾는 과정: 루트에서 리프블록까지 아래쪽으로 진행
    2) 수평적 탐색
        - 범위 스캔
        - 리프 블록을 인덱스 레코드 간 논리적 순서에 짜라 좌우,우좌로 스캔
    - 결합 인덱스 구조와 탐색
- 4) ROWID 포맷
    - 데이터 파일 번호, 블록 번호, 로우 번호: 테이블 레코드의 물리적 위치정보를 포함
    - pseudo 컬럼: rowid값이 테이블에 실제 저장되지는 않음
    - 6 byte: 
        - 파티션 되지 않은 일반 테이블에 생성한 인덱스
        - 파티션 된 테이블에생성한 로컬 파티션 인덱스
    - 10 byte
        - 파티션 테이블에 생성한 글로벌 파티션 인덱스
        - 파티션 테이블에 생성한 비파티션 인덱스
    - 제한된 rowid 포맷 : 데이터파일번호(4자리) + 블록 번호(8자리) + 로우 번호(4자리) -> 16자리 + . 2자 -> 18
        - 데이터파일번호: 로우가 속한 데이터파일 번호, 데이터베이스 내 유일한 값
        - 블록번호: 해당 로우가 저장된 데이터 블록 번호, 데이터파일 내의 상대적 번호
        - 로우번호: 블록 내에서 각 로우에 붙여진 일련번호, 0부터 시작
        - 순서: 블록.로우.데이터파일
    - 확장 rowid 포맷: 데이터오브젝트(6자리) + 데이터파일번호(3자리) + 블록번호(6자리) + 로우번호(3자리) -> 18
    - dbms_rowid 패키지: 각 구성요소 정보, 확장 rowid > 제한 rowid 포맷으로 변경
        - rowid_to_restricted, rowid_object(ri), rowid_relative_fno(ri), rowid_block_number(ri), rowid_row_number(ri), rowid_type


2. 인덱스 기본 원리
- B*tree 인덱스를 제대로 사용하려면 범위 스캔 가능 > 인덱스 선두 컬럼이 조건절에 사용되지 않으면 범위스캔 불가
    > 인덱스 선두 컬럼이 조건절에 사용되더라도 인덱스사용불가/범위스캔불가 가능성 있음
- 1) 인덱스 사용이 불가능하거나 범위 스캔이 불가능한 경우 
    - 인덱스 범위 스캔 불가: 조건절에 가공한 인덱스 컬럼을 사용/부정형비교<>,is not nul
    - 오라클은 단일 컬럼 인덱스에 null 값은 저장하지 않음
        > 결합 인덱스는 인덱스 구성 컬럼중 하나라도 값이 Null이 아닌 레코드는 인덱스에 포함 > 필터링 가능
    - is null 조건 검색은 인덱스 사용 불가
        > but 인덱스 구성 컬럼에 이외의 조건식이 하나라도 있으면 Range Scan가능 (혹은 다른 구성컬럼이 Not Null 제약 이라면)
- 2) 인덱스 컬럼의 가공
    - nvl(주문수량, 0) < 100
        - 주문수량이 NOT NULL 컬럼 : nvl 함수 제거하여 range scan 가능
            - NOT NULL 컬럼이 아니고 해당하는 건수가 아주 많다면 -> TABLE FULL SCAN 유리
                - 해당하는 건수가 적다면 함수기반 인덱스(FBI) 생성 고려
    - 튜닝사례 1
        - 지수구분코드 || 지수업종코드 in ('1001', '2003') -> (지수구분코드, 지수업종코드) in (('1','001'),('2','003'))
    - 튜닝사례 2
        - decode 문을 분석해 논리적으로 동일한 결과를 리턴하도록 인덱스 선두 컬럼에 가공 안되게 수정
- 3) 묵시적 형변환
    - 숫자형과 문자형을 비교할 때 숫자형으로/문자형과 날짜형이 만나면 날짜형으로 > 명시적으로 변환함수를 사용하자!!!
        > 인덱스 컬럼과 비교되는 반대쪽을 인덱스 컬럼 데이터 타입에 맞춰주는게 이상적
    - 만약 묵시적 형변환이 일어난 컬럼이 조건절의 좌변이라면 가공이 되어 Range Scan 불가
    - Like 쓸 땐 숫자형도 문자형으로 변환
    - 사용시 주의사항
        decode(a,b,c,d) : a=b이면 c 아니면 d
            > 출력되는 타입은 C의 타입, 만약 c가 null이면 D는 varchar2 타입으로 형변환
            > d는 숫자인데 c가 null이면 varchar2로 취급하며 3000 vs 950 일 때 950으로 출력
    - 함수기반 인덱스(FBI) 활용
        - 묵시적 형변환으로 성능이슈가 발생 but 프로그램을 바꿀 만큼 시간적 여유가 없을 떄
        - ex) Create index emp_x01 on emp(to_number(v_deptno))


3. 다양한 인덱스 스캔방식



4. 테이블 Random 액세스 부하



5. 테이블 Random 액세스 최소화 튜닝



6. IOT, 클러스터 테이블 활용



7. 인덱스 스캔 효율



8. 인덱스 설계



9. 비트맵 인덱스