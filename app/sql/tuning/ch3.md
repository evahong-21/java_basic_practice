# 3. 인덱스 튜닝

## 3.1 테이블 액세스 최소화
### 3.1.1 테이블 랜덤 액세스
- TABLE ACCESS (BY INDEX ROWID)
- 인덱스 ROWID는 논리적 주소: 포인터가 아님 > 디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보
    - 오라클은 테이블 블록이 수시로 버퍼캐시에서 밀려났다가 다시 캐싱 > 인덱스에서 포인터로 직접 연결 불가
    - DBA(Data Block Address)를 이용해 해시 알고리즘으로 버퍼 블록 찾음 > 데이터파일번호+블록번호
  vs. 메인 메모리 DB: 디스크를 경유하지 않고 데이터를 메모리에서 읽음 > 메모리 상의 주소정보(포인터) 사용 > 비용 낮고 속도 빠름
- I/O 매커니즘 복습
  - 버퍼캐시: DBA를 해시 함수에 입력하여 해시 체인을 찾음 > 버퍼 헤더(항상 같은 해시 체인에 연결됨)를 찾음 
    > 실제 데이터가 담긴 버퍼 블록은 매번 다른 위치에 캐싱 > 메모리 주소를 버퍼 헤더에서 갖고 있음
    - 정리! : 해싱 알고리즘으로 버퍼헤더를 찾고 거기서 얻은 포인터로 버퍼 블록 찾아감 

### 3.1.2 인덱스 클러스터링 팩터: Clustering Factor(CF)
  - 군집성 게수 : 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 모여있는 정도
  - CF가 좋은 컬럼에 생성한 인덱스는 검색 효율 좋음 > 테이블 액세스량에 비해 블록 I/O가 적게 발생하므로
  - 버퍼 Pinning : 인덱스 ROWID로 테이블 액세스 할 때 오라클은 래치 획득과 해시체인스캔과정을 거쳐 어렵게 찾아간 테이블 블록에 대한 포인터를 바로 해제 X
    > 이 상태에서 다음 인덱스 ROWID를 읽었는데 직전과 같은 테이블 블록이다? > 래치 획득과 해시체인스캔과정을 생략하고 바로 테이블 블록 읽기 가능 
    > 논리적인 블록 I/O 과정을 생략하게 가능

### 3.1.3 인덱스 손익분기점: Index range scan에 의한 테이블 액세스가 Table Full Scan 보다 느려지는 지점
- 인덱스가 더 느려지는 핵심적인 두가지 요인
  1) Table Full Scan은 시퀀셜 액세스, 인덱스 ROWID는 랜덤 액세스 방식
  2) Table Full Scan은 MultiBlock I/O, 인덱스 ROWID는 SingleBlock I/O
  3) CF 가 나쁠 떄 (논리적I/O, 물리적 I/O 모두 늘어남)
    - 손익분기점이 5퍼 미만에서 결정/심할때(BCHR이 매우 안좋을 때)는 1퍼 미만
    - 반대로 좋을 땐 90퍼까지 올라가기도 함
- 버퍼캐시 히트율과 인덱스 손익분기점
  - 데이터 양이 많아질 수록 버퍼캐시 히트율이 낮아질 수밖에 없음 > 손익분기점이 더 낮아짐
- 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝
  온라인 : 보통 소량 데이터 -> 대부분 NL 방식(Nested Loop: 인덱스를 이용하는 조인 방식 - 소트 연산 생략)의 조인, 인덱스 유리
  배치 : 대량 데이터로 Full Scan과 해시 조인 유리
  초대용량 테이블은 파디션 활용 전략 필요 & 병렬처리 > Full Scan을 빠르게 처리하기 위함

### 3.1.4 인덱스 컬럼 추가
- 테이블 액서스 단계 필터조건에 의해 버려지는 레코드 많을때 -> 인덱스 컬럼 추가
  > 인덱스 스캔량은 줄지 않지만 테이블 랜덤 액세스 횟수 줄여줌

### 3.1.5 인덱스만 읽고 처리
- 테이블 랜덤 액세스 아무리 많아도 필터 조건에 의해 버려지는 레코드가 거의 없다면? 
- Covered 쿼리: 인덱스만 읽어서 처리하는 쿼리 / Covered 인덱스: 그 쿼리에 사용한 인덱스
  > 테이블 액세스를 아예 발생시키지 X
- Include 인덱스: 오라클엔 없고 SQL Server에 존재
  - 순전히 테이블 액세스를 줄이기 위해 사용
  - 인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 저장하여 필터링
  - sort 생략 가능하지 않음 / 같은 조건일 떄 인덱스 스캔량이 더 많음
  - Create index index_nm on table (column1) include (column2)

### 3.1.6 인덱스 구조 테이블 
- IOT(Index-Organized Table = 클러스터형 인덱스) : 인덱스가 고비용 구조니 테이블 자체를 인덱스 구조로 생성하면 어떨까?
- 테이블을 찾아가기 위한 ROWID 정보가 아닌 테이블 데이터를 저장 > 인덱스 리프 블록에 테이블 정보가 있다는 뜻
- organization index; : 테이블을 인덱스 구조로 만드는 구문 > 정렬 상태를 유지하면서 데이터 입력
- orgnization heap : 일반적인 테이블은 힙 구조 > 데이터 입력시 랜덤 방식 사용
- 인위적으로 클러스터 팩터(CF) 를 좋게 만드는 방법 중 하나
  - 레코드 들이 100퍼 정렬 된 상태 > 랜덤 액세스가 아닌 시퀀셜 방식으로 액세스.
    > between이나 부등호 조건으로 넓은 범위를 읽을 때 이득
- Create table index_nm (column number, column2 varchar(10), constraint index_nm_pk primry key(column))

### 3.1.7 클러스터 테이블 
1) 인덱스 클러스터 테이블
- 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장 > 한 블록에 모두 못담을 땐 새로운 블록을 할당해서 클러스터 체인에 연결
  > 다중 테이블 클러스터 : 여러 테이블 레코드를 같은 블록에 저장 가능 (일반 테이블은 하나의 데이터 블록을 여러 테이블이 공유 불가)
- 클러스터링 인덱스(IOT)와 다름!! 정렬되지 않고 그냥 같은 값끼리 모여있는 것
- create cluster A# (column_nm number(2)) index; : 클러스터 생성
- create index A#-idx on cluster A# : 클러스터 인덱스 정의
- 일벤 테이블은 인덱스레코드:테이블 레코드 = 1:1 / 클러스터 인덱스는 1:M으로 클러스터 인덱스 키값은 항상 Unique하다
- INDEX (UNIQUE SCAN) OF 'C_A#_idx' (INDEX(CLUSTER))
2) 해시 클러스터 테이블
- 해시 알고리즘으로 클러스터를 찾아감
- create cluster A# (column_nm number(2)) hashkeys 4; : 클러스터 생성 (정의 안해도 되나 봄!)
- TABLE ACCESS (HASH) OF 'DEPT' (CLUSTER (HASH))


## 3.2 부분범위 처리 활용
- 인덱스 손익분기점의 한계를 극복할 히든카드!
- 인덱스로 액세스할 대상 레코드가 아무리 많아도 빠른 응답속도 가능

### 3.2.1 부분범위 처리
- OLTP : 'Online Transaction Processing'환경에서 DBMS가 데이터를 모두 읽어 한번에 전송 X > 일정량 전송하고 멈춤
  > 서버 프로세스는 CPU를 OS에 반환 후 대기큐에서 잠 > 다음 Fetch Call 받을 때 대기큐에서 나와 다음 데이터 일정량을 읽고 전송 > 다시 잠
- 부분 범위 처리: 전체 쿼리 결과집합을 연속으로 전송하는 것이 아닌 Fetch Call이 있을 때마다 일정량씩 나누어 전송하는 것
- 전체 범위 처리: order by 컬럼이 인덱스 선두컬럼에 해당하지 않는다면 전체 sort 를 해야하므로.
  > Sort Area와 Temp 테이블 스페이스까지 이용할 것
- Array Size 를 크게 조정한다면 Fetch Call횟수를 그만큼 줄일 수 있음
  > but 앞쪽 일부 데이터만 Fetch 하다가 멈추는 프로그램이라면 작게 설정하는것이 유리: 사용하지 않고 버릴 뒤쪽 레코드에 대한 자원 소모
- Initial Fetch 가 100이고 Array Size가 20이라면? 
  > 처음엔 Fetch Call이 5번 일어나며 100개의 데이터가 보여줌 > 그 뒤엔 1 Fetch Call 과 20개의 데이터가 추가로 노출

### 3.2.2 부분 범위 처리 구현
- excute 메서드에 fetch 메서드를 array size에 따라 호출

### 3.2.3 OLTP 환경에서 부분범위 처리에 의한 성능개선 원리
- 인덱스 부분범위 처리 원리를 활용하면 OLTP환경에서 극적인 성능개선 효과 얻을 수 잇음
  index는 항상 정렬상태를 유지 -> 쿼리에 order by 가 있어도 실행계획에선 X
- 앞쪽 일부만 출력하고 멈출 수 있는가가 부분범위 처리의 핵심
- n Tier 아키텍져에서도 부분범위 처리 가능
- 배치 I/O
  - 테이블 블록에 대한 디스크 I/O 콜을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리 
    > 읽는 블록마다 건건이 I/O Call을 발생시키는 비효율을 줄이기 위해 고안한 기능
  - 인덱스를 이용해서 출력하는 데이터 정렬 순서가 매번 다를 수 있다
  - 기존 index 사용한 스캔은 정렬이 되어 있다면 order by 실행계획이 생략되지만,
    > batch_table_access_by_rowid 힌트를 사용한다면 order by 실행계획이 생략 되지 않는다
  -> 해당 힌트는 정렬을 보장하지 않으므로 옵티마이저가 생략하지 않음.


## 3.3 인덱스 스캔 효율화
- IOT, 클러스터, 파티션은 테이블 랜덤 액세스를 최소화 하는데 매우 효과적인 저장 구조 > 운영 환경에서 성능검증 테스트 진행 필요
- 인덱스 컬럼 추가 > 운영 환경에서 가능한 일반적인 튜닝 기법

### 3.3.1 인덱스 탐색
- 수직적 탐색은 스캔 시작점을 찾는 과정 

### 3.3.2 인덱스 스캔 효율성
- 조건절이 스캔량을 줄이는 역할을 하는지 중요
  인덱스 선행컬럼이 조건절에 없거나 '='조건이 아니면 인덱스 스캔 과정에 비효율 발생
  선두 컬럼 : 인덱스 구성 맨 앞에 있는 컬럼
  선행 컬럼 : A 컬럼보다 상대적으로 앞쪽에 높인 컬럼
- 인덱스 스캔 효율성 측정: 인덱스를 스캔하고 얻은 레코드가 열개인데 그 과정에 많은 블록을 읽으면 비효율

### 3.3.3 액세스 조건과 필터 조건
- 인덱스 액세스 조건 : 인덱스 스캔 범위 결정(수직적 탐색 - 스캔 시작점 결정, 어디서 멈출지도 결정)
- 인덱스 필터 조건 : 테이블로 액새스할 지 결정하는 조건
- 테이블 필터 조건 : 쿼리 수행 다음단계로 전달, 최종 결과집합에 포함할지 결정
- 인덱스 이용한 테이블 액세스 비용
  = 수직적 탐색 비용 + 수평적 탐색 비용 + 테이블 랜덤 액세스 비용
  = 루트와 브랜치 레벨에서 읽는 블록 수 + 리프 블록을 스캔하는 과정에 읽는 블록 수 + 테이블 액세스 과정에 읽는 블록 수

### 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성
- 선행컬렁이 모두 = 조건인 상태에서 첫번째 나타나는 범위검색(부등호, BETWEEN, LIKE) 조건까지만 만족하는 인덱스 레코드는 모두 연속해서 모여있다. (인덱스 액세스 조건)
  - 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어진다. (인덱스 필터조건)

### 3.3.5 인덱스 선행컬럼이 등치(=) 조건이 아닐 떄 생기는 비효율
- 인덱스 스캔 효율성: 인덱스 컬럼을 조건절에 모두 등치 조건으로 사용할 때 가장 좋음
- 인덱스 선두 컬럼에 범위검색 조건 사용시 조건을 만족하지 않은 레코드까지 스캔하는 비효율 생김

### 3.3.6 BETWEEN을 IN-List로 전환
- 범위검색 컬럼을 맨 뒤로 바꿀 수 없는 인덱스라면 -> BETWEEN조건을 IN-LIST 로 전환 ex) in (1,2,3)
  > IN-List 개수만큼 UNION ALL 브랜치 생성 > 모든 컬럼을 = 조건으로 검색 > 비효율 제거
  - IN-LIST 항목 개수가 늘어난다면 NL방식의 조인문이나 서브쿼리로 '=' 구현
  - 단점 : 범위 조건이 서로 가깝다면 BETWEEN이 나을듯 -> 수평적 스캔보다 수직적 탐색에서 더 많은 블록을 사용할 위험.

### 3.3.7 Index Skip Scan 활용
- 선두 컬럼이 범위조건이었지만 IN-List 보다 결과가 나은 경우 존재
- 선두 컬럼이 BETWEEN 이면서 나머지 검색 조건을 만족하는 데이터가 서로 멀리 떨어져 있을 때 위력

### 3.3.8 IN 조건은 '='인가
- 아니다. =가 되려면 IN-List Iterator 방식으로 풀려야 한다 > 그렇지 않으면 IN 조건은 필터조건이다.
- NUM_INDEX_KEYS(테이블 인덱스명 숫자) 힌트 : 숫자 컬럼까지만 액세스 조건으로 사용하라는 의미
  - 인덱스 액세스 조건으로 사용X, 필터로 사용하려면? RTRIM(column), where and column || '' ~ 

### 3.3.9 BETWEEN과 LIKE 스캔 범위 비교
- 데이터 분포와 조건절 값이 따라 인덱스 스캔량이 서로 다를 수 있음
  LIKE보다 BETWEEN을 쓰는게 좋다.

### 3.3.10 범위검색 조건을 남용할 때 생기는 비효율
- 인덱스 구성 컬럼일 때 LIKE와 BETWEEN등을 남발하지 말자. 
  > 인덱스 스캔 범위가 늘어남 > 액세스 조건이 필터 조건으로 수정된다.

### 3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교
- OR조건을 인덱스 선두 컬럼에 사용하지 말자! > 인덱스 액세스 X, 인덱스 필터 X, 테이블 필터 O
- 범위 검색 조건을 남용하지 말자! (LIKE, BETWEEN)
  1) 인덱스 선두 컬럼 X 
  2) Null 허용 컬럼 X(결과 집합 오류)
  3) 숫자형 컬럼(형변환 -> 필터조건)
  4) 가변길이 컬럼(length 조건 걸기)
- UNION ALL 사용 : 옵션 조건 컬럼을 인덱스 액세스 조건으로 사용, null 허용 컬럼도 가능, 유일한 단점 -> 쿼리 길이가 길어짐
- NVL/DECODE 함수 활용
  - OR Expansion 쿼리변환: 조건 컬럼을 함수 인자로 사용(인덱스 컬럼 가공) 했는데 인덱스 액세스 조건으로 작용하는 이유
   > 옵션 조건 처리용 NVL/DECODE 함수를 여러개 사용하면 그중 변별력이 가장 좋은 컬럼 기준으로 한번만 수행됨
  - 장점 : UNION ALL보다 단순하면서 같은 성능
  - 단점 : NULL 허용 컬럼에 사용 X
- Dynamic SQL : 옵티마이저 힌트를 명시하면 동적으로 구성된 조건절과 상충 문제 가능성
  > 조건절을 동적으로 구성 가능 -> 옵션 조건에 = 연산자를 사용 가능 > 액세스 조건으로 사용 가능

### 3.3.12 함수호출부하 해소를 위한 인덱스 구성
- PL/SQL 사용자 정의 함수는 매우 느림
  1) 가상머신(VM) 상에서 실행되는 인터프리터 언어
    - PL/SQL 엔진은 바이트 코드를 런타임 시 해석하면서 실행 / Native 코드로 완전히 컴파일된 내장 함수에 비해 느림
  2) 호출 시마다 컨텍스트 스위칭 발생
    - SQL실행엔진과 PL/SQL 가상머신 사이에 컨텍스트 스위칭 발생
  3) 내장 SQL에 대한 Recursive call 발생
    - 느린 가장 결정적 요소
    - sql 쿼리에 사용되는 사용자함수가 호출 되는대로(select 되는 row 수만큼) call한다.
- 효과적인 인덱스 구성을 통한 함수 호출 최소화
  - 어떻게 인덱스를 구성하느냐에 따라 테이블 액세스 단계/인덱스 스캔/인덱스 액세스 로직을 탄다


## 3.4 인덱스 설계
### 3.4.1 인덱스 설게가 어려운 이유
- 인덱스가 많으면 생기는 문제
    DML 성능 저하 (TPS저하) / 데이터베이스 사이즈 증가(디스크 공간 낭비)/ 데이터베이스 관리 및 운영비용상승
    - ex. 한 테이블에 인덱스가 6개 -> 신규 데이터가 insert 때 6개 인덱스에도 데이터 입력 필요
      > 인덱스는 정렬 되어 있어야 하므로 수직적 탐색 + 여유공간이 없다면 인덱스 분할도 발생

### 3.4.2 가장 중요한 두가지 선택 기준
- Index Range Scan 방식을 사용할 때
    1) 인덱스 선두 컬럼을 조건절에 반드시 사용, 자주 사용하는 컬럼 선정
    2) '='조건으로 자주 조회하는 컬럼을 앞쪽에 둔다

### 3.4.3 스캔 효율성 이외의 판단 기준
- 스캔 효율성 이외의 판단 기준
    수행빈도 : NL 방식으로 조인하는 2개의 테이블(outer/inner의 차이)
      > NL 조인에서 Inner 쪽 인덱스 스캔과정의 비효율 -> *Outer 액세스 횟수
      > inner 쪽 인덱스는 = 조건 컬럼 선두 , 테이블 액세스 없이 인덱스에서 필터링 마치도록 구성 필요
    데이터량 / 업무상 중요도 / 클러스터링 팩터 / DML부하 / 저장공간 / 인덱스 관리 비용
### 3.4.4 공식을 초월한 전략적 설계
- 원래는 범위조건이 인덱스 선두조건으로 두지 않는게 공식이었으나 상황에 따라 선두에 해야할 떄도 존재

### 3.4.5 소트 연산을 생략하기 위한 컬럼 추가
- 인덱스 구성 공식
  1) '=' 연산자로 사용한 조건절 컬럼 설정
  2) ORDER BY 절에 기술한 컬럼 추가
  3) '=' 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정
- ORDER BY 절이 있어도 소트 연산이 발생하지 않도록 하는 방법
    = 조건 : order by 컬럼 위치 아무데나 가능
    =아닌 조건 : order by 컬럼보다 무조건 뒤에 
    결론 : I/O를 최소화 하면서 소트연산 생략방법 
        '='연산자 컬럼 > Order by 컬럼 > '='연산자 아닌 조건절 컬럼(데이터 분포 고려)
- IN 조건은 '='가 아니다
  - IN 조건이 =이 되는경우 : Union all을 사용한 In-list iterator 방식
  - 소트 연산을 생략하려면 IN 조건절이 IN-list iterator 방식으로 풀리면 안됨
    > 즉 IN 조건절을 인덱스 액세스 조건으로 사용하면 X > 필터 조건으로 사용해야 함 

### 3.4.6 결합 인덱스 선택도 
  - 선택도 낮게 : 전체 레코드 에서 조건절에 의해 선택되는 레코드 비울
    > 선택도 * 총 레코드 = 카디널리티
    - 선택도가 높으면 인덱스를 쓰는 의미가 없음 > 찾게되는 값이 많으면 그만큼 테이블 I/O도 늘어날 것이기 때문
  - 인덱스 생성 여부 결정할 때 선택도가 중요하지만 컬럼간 순서를 결정할 땐 필수조건여부, 연산자형태가 더 중요한 판단기준
    > 선택도가 낮다고 무조건 인덱스 선행 컬럼에  두는건 의미가 없거나 오히려 손해일 수 있음

### 3.4.7 중복 인덱스 제거 
- 완전 중복: A1 인덱스 선두 컬럼이 A2, A3 인덱스 전체를 완전히 포함할 때
- 불완전 중복: 선두 컬럼은 같지만 두번 째 컬럼이 모두 다른 인덱스 사이. 선두 컬럼의 카디널리티가 적으면 인덱스 여러개 필요 X
- 어렵다,,, 카디널리티가 매우 낮은지도 확인하고 중복 제거 (완전중복/불완전중복)

### 3.4.8 인덱스 설계도 작성
