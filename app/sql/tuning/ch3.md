3. 인덱스 튜닝

3.1 테이블 액세스 최소화

- 인덱스 손익분기점
  Index range scan에 의한 테이블 액세스가 Table Full Scan 보다 느려지는 지점
- 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝
  온라인 : 보통 소량 데이터 -> 대부분 NL 방식의 조인, 인덱스 유리
  배치 : 대량 데이터로 Full Scan과 해시 조인 유리
  초대용량 테이블은 파디션 활용 전략 필요 & 병렬처리
- 테이블 액서스 단계 필터조건에 의해 버려지는 레코드 많을때 -> 인덱스 컬럼 추가

3.2 부분범위 처리 활용

- OLTP : 'Online Transaction Processing'
  index와 부분처리 활용
  index는 항상 정렬상태를 유지 -> 쿼리에 order by 가 있어도 실행계획에선 X
- 앞쪽 일부만 출력하고 멈출 수 있는가가 부분범위 처리의 핵심
- 배치 I/O
  인덱스를 이용해서 출력하는 데이터 정렬 순서가 매번 다를 수 있다
  index로 정렬이 되어 있다면 order by 실행계획이 생략되지만,
  batch_table_access_by_rowid 힌트를 사용한다면 order by 실행계획이 생략 되지 않는다
  -> 해당 힌트는 정렬을 보장하지 않으므로 옵티마이저가 생략하지 않음.

3.3 인덱스 스캔 효율화

- 조건절이 스캔량을 줄이는 역할을 하는지 중요
  인덱스 선행컬럼이 조건절에 없거나 '='조건이 아니면 인덱스 스캔 과정에 비효율 발생
  선두 컬럼 : 인덱스 구성 맨 앞에 있는 컬럼
  선행 컬럼 : A 컬럼보다 상대적으로 앞쪽에 높인 컬럼
- 액세스 조건과 필터 조건
  인덱스 액세스 조건 : 인덱스 스캔 범위 결정(수직적 탐색 - 스캔 시작점 결정, 어디서 멈출지도 결정)
  인덱스 필터 조건 : 테이블로 액새스할 지 결정하는 조건
  테이블 필터 조건 : 쿼리 수행 다음단계로 전달, 최종 결과집합에 포함할지 결정
  - 첫번째 나타나는 범위검색(부등호, BETWEEN, LIKE) 조건까지만 만족하는 인덱스 레코드는 모두 연속해서 모여있다. (인덱스 액세스 조건)
  - 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어진다. (인덱스 필터조건)
- 인덱스 이용한 테이블 액세스 비용
  = 수직적 탐색 비용 + 수평적 탐색 비용 + 테이블 랜덤 액세스 비용
  = 루트와 브랜치 레벨에서 읽는 블록 수 + 리프 블록을 스캔하는 과정에 읽는 블록 수 + 테이블 액세스 과정에 읽는 블록 수
- 범위검색 컬럼을 맨 뒤로 바꿀 수 없는 인덱스라면 -> BETWEEN조건을 IN-LIST 로 전환 ex) in (1,2,3)
  혹은 NL방식의 조인문이나 서브쿼리로 = 구현
  단점 : 범위 조건이 서로 가깝다면 BETWEEN이 나을듯 -> 수평적 스캔보다 수직적 탐색에서 더 많은 블록을 사용할 위험.
- Index Skip Scan 활용
  선두 컬럼이 범위조건이었지만 IN-List 보다 결과가 낫다
  선두 컬럼이 BETWEEN 이어서 나머지 검색 조건을 만족하는 데이터가 서로 멀리 떨어져 있을 때 위력
- IN 조건은 '='인가
  아니다. =가 되려면 IN-List Iterator 방식으로 풀려야 한다.
  그렇지 않으면 IN 조건은 필터조건이다.
  NUM_INDEX_KEYS(테이블 인덱스명 숫자) 힌트 : 숫자 컬럼까지만 액세스 조건으로 사용하라는 의미
- BETWEEN과 LIKE 스캔 범위 비교
  데이터 분포와 조건절 값이 따라 인덱스 스캔량이 서로 다름
  LIKE보다 BETWEEN을 쓰는게 좋다.
- OR조건을 인덱스 선두 컬럼에 사용하지 말자!
  인덱스 액세스 X, 인덱스 필터 X, 테이블 필터 O
- 범위 검색 조건을 남용하지 말자! (LIKE, BETWEEN)
  인덱스 선두 컬럼 X, Null 허용 컬럼 X(결과 집합 오류), 숫자형 컬럼(형변환 -> 필터조건), 가변길이 컬럼(length 조건 걸기)
- UNION ALL 사용 : 유일한 단점 -> 쿼리 길이가 길어짐
- NVL/DECODE 함수 활용
  장점 : UNION ALL보다 단순하면서 같은 성능
  단점 : NULL 허용 컬럼에 사용 X
- Dynamic SQL : 옵티마이저 힌트를 명시하면 동적으로 구성된 조건절과 상충 문제 가능성
- PL/SQL 함수호출부하
  느림이유

  1. 가상머신(VM) 상에서 실행되는 인터프리터 언어
  2. 호출 시마다 컨텍스트 스위칭 발생
  3. 내장 SQL에 대한 Recursive call 발생
     어떻게 인덱스를 구성하느냐에 따라 테이블 액세스 단계/인덱스 스캔/인덱스 액세스 로직을 탄다

3.4 인덱스 설계
- 인덱스가 많으면 생기는 문제
    DML 성능 저하 (TPS저하) / 데이터베이스 사이즈 증가(디스크 공간 낭비)/ 데이터베이스 관리 및 운영비용상승
- Index Range Scan 
    인덱스 선두 컬럼을 조건절에 반드시 사용, 자주 사용하는 컬럼 선정
    '='조건으로 자주 조회하는 컬럼을 앞쪽에 둔다
- 스캔 효율성 이외의 판단 기준
    수행빈도 : NL 방식으로 조인하는 2개의 테이블(outer/inner의 차이)
    데이터량 / 업무상 중요도 / 클러스터링 팩터 / DML부하 / 저장공간 / 인덱스 관리 비용
- 공식을 초월한 전략적 설계
    원래는 범위조건이 인덱스 선두조건으로 두지 않는게 공식이었으나 상황에 따라 선두에 해야할 떄도 존재
- 소트 연산을 생략하기 위한 컬럼 추가
    = 조건 : order by 컬럼 위치 아무데나 가능
    =아닌 조건 : order by 컬럼보다 무조건 뒤에 
    결론 : I/O를 최소화 하면서 소트연산 생략방법 
        '='연산자 컬럼 > Order by 컬럼 > '='연산자 아닌 조건절ㄹ 컬럼(데이터 분포 고려)
    - IN 조건이 =이 되는경우 : Union all을 사용한 In-list iterator 방식
    - 소트 연산을 생략하려면 IN 조건절이 IN-list iterator 방식으로 풀리면 안됨
        즉 IN 조건절을 인덱스 액세스 조건으로 사용하면 X 
- 결합 인덱스 선택도 
    선택도 낮게 : 전체 레코드 에서 조건절에 의해 선택되는 레코드 비울
    인덱스 생성 여부 결정할 때 선택도가 중요하지만 컬럼간 순서를 결정할 땐 필수조건여부, 연산자형태가 더 중요한 판단기준
- 중복 인덱스 제거 : 어렵다,,, 카디널리티가 매우 낮은지도 확인하고 중복 제거 (완전중복/불완전중복)
