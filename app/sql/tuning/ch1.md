1. sql 처리과정과 I/O

1-1. SQL 파싱과 최적화
- 구조적(structured), 집합적(set-based), 선언적(declarative)
- 프로시저: 결과 집합을 만드는 과정은 절차적(Procedual)이므로 필요
- SQL 옵티마이저: 프로시저를 만들어 내는 DBMS 내부 엔진
  1) 사용자로부터 전달받은 쿼리를 수행하는데 후보군 실행계획 찾기
  2) 데이터 딕셔너리에 미리 수집해둔 오브젝트 통계 및 시스템 통계정보를 이용해 실행계획의 예상비용 산정
  3) 최저 비용을 나타내는 실행계획 선택
- SQL 최적화: DBMS 내부에서 프로시저를 작성하고 컴파일 해서 실행 가능한 상태로 만드는 전 과정
  1) SQL 파싱
    - 파싱트리 생성: SQL문을 이루는 개별 구성요소를 분석하여 생성
    - Syntax 체크: 문법적 오류가 없는지 확인(사용할 수 없는 키워드/순서/누락)
    - Semantic 체크: 의미상 오류가 없는지 확인(존재하지 않는 테이블, 컬럼, 권한)
  2) SQL 최적화
    - 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로 생성 -> 가장 효율적인 하나 선택
  3) 로우 소스 생성
    - 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅
- 실행계획(Execution Plan) : SQL 실행경로 미리보기(마치 네비게이션)
  - 비용(Cost) 절감: 쿼리를 수행하는 동안 발생할 것으로 예상되는 I/O 횟수 또는 소요시간을 표현한 값
  - 옵티마이저 힌트를 통해 실행계획 액세스 경로를 바꿀 수 있음
- 옵티마이저 힌트
  - 힌트끼리는 , 로 구분하지 않고 그냥 나열
  - 스키마를 명시하지 않는다
  - Alias로 테이블을 명칭했다면 인덱스에도 AS 명 사용
  - 자주 사용하는 힌트 목록
    1. 최적화 목표
    2. 액세스 방식
    3. 조인 순서
    4. 조인방식
    5. 서브쿼리 팩토링
    6. 쿼리변환
    7. 병렬 처리
    8. 기타


1-2. SQL 공유 및 재사용
- SGA(System Global Area): 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어구조를 캐싱하는 메모리 공간
- 라이브러리 캐시: SGA에 구셩요소, SQL파싱, 최적화, 로우소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있게 캐싱해두는 메모리공간.
- 소프트 파싱: SQL을 라이브러리 캐시에서 찾으면 바로 실행단계로 넘어가는 것
- 하드 파싱: 라이브러리 캐시에 없어 최적화(최적화, 로우소스 생성)부터 실행단계로 넘어가는 것
  CPU 많이 소모
- 옵티마이저가 사용하는 정보 : 테이블,컬럼,인덱스 구조 / 오브젝트 통계 / 시스템 통계 / 옵티마이저 관련 파라미터
- 바인드 변수의 필요성
  - 사용자정의함수/프로시저, 트리거, 패키지는 생성할 때부터 이름 갖음
  - SQL 은 이름이 없고 전체 SQL 텍스트가 이름 역할 -> SQL이 조금 바뀌면 다른 객체가 새로 탄생하는 구조
    ex) FROM A 과 from A 도 다른 SQL로 취급 -> 서로 다르게 라이브러리 캐시에 저장
  - 그러므로 바인딩변수를 사용하면 라이브러리 캐시에 한번만 저장되어 경합을 줄이고 자원을 아낌


1-3. 데이터 저장 구조 및 I/O 매커니즘
- I/O 튜닝은 곧 SQL 튜닝
- SQL이 느린 이유는 디스크 I/O (메모리 캐시 I/O랑은 조금 다름)
- I/O 가 진행될 땐 CPU를 OS에 반환하고 수면 -> 일해야할 프로세스가 잠을 자고 있으니 성능이 느려짐
- 데이터베이스 저장 구조
  1) 테이블스페이스: 데이터를 저장하려면 먼저 생성 필요. 세그먼트를 담는 콘테이너
    - 여러개의 데이터파일(디스크 상의 물리적인 OS파일) 로 구성
    - 데잍터파일: 디스크 상의 물리적인 OS파일
  2) 세그먼트: 여러 익스턴트로 구성, 테이블, 인데스처럼 저장공간이 필요한 오브젝트
    - 파티션 구조가 아니라면 테이블, 인덱스 모두 하나의 세그먼트 -> 파티션 구조라면 그 파티션이 하나의 세그먼트
    - LOB 컬럼도 그 자체로 하나의 세그먼트
    - 세그먼트에 있는 익스턴트는 여러개의 데이터파일에 존재할 수 있음 -> 연속된 익스턴트가 존재하는건 아닌 이유.
  3) 익스턴트: 공간을 확장하는 단위, 연속한 여러개의 데이터 블록(=page)들의 집합
    - 한개의 익스턴트는 한 테이블이 독점
  4) 데이터 블록(=page): 데이터를 읽고 쓰는 단위
    - 한개의 블록 데이터는 한 테이블이 독점
    - DBA(Data Block Address): 디스크 상에서 몇 번 데이터파일의 몇번째 블록인지 고유 주소값
    - 인덱스: 인덱스 ROWID -> DBA + Row 번호 
    - 특정 레코드를 읽고 싶어도 전체 블럭을 다 읽어야함
- 블록 액세스 하는 방식(테이블 또는 인덱스 블록을 읽는 방식)
  1) 시퀀셜 액세스: 논리적 또는 물리적으로 연결된 순서에 차례대로 블록 액세스
    - 인덱스 리프 블록은 앞뒤를 가르키는 주소값 존재
    - 오라클은 세그먼트 헤더에 익스텐트 목록을 맵으로 관리, 익스텐트 맵은 각 인스턴트의 첫번째 블록 주소값을 갖는다
    - Full Table Scan: 읽어야 할 익스턴트 목록을 맵에서 얻어서 첫번째 블록부터 연속된 블록을 순서대로 읽는 것
  2) 랜덤 액세스
    - 논리적, 물리적 순서 X, 레코드 하나 읽기 위해 한 블록씩 접근 방식
- 논리적 I/O vs 물리적 I/O
  - DB 버퍼 캐시 : 라이브러리 캐시처럼 SGA 의 구성요소 중 하나
    - 라이브러리 캐시: SQL실행계획, DB 저장형 함수/프로시저 캐싱하는 '코드캐싱'
    - DB 버퍼 캐시(=데이터 캐시): 디스크에서 어렵게 읽은 블록을 캐싱 -> 같은 블록에 대한 I/O Call 줄임
  - 논리적 I/O: SQL문을 처리하는 과정에 메모리 버퍼캐시에서 발생한 총 블록 I/O
    - 메모리 I/O(전기적 신호) 와 같다고 해도 무방
    - SQL을 수행하면서 읽은 총 블록 I/O
  - 물리적 I/O: 디스크에서 발생한 총 블록 I/O
    - SQL처리중 읽을 블록을 버퍼 캐시에서 찾지 못할 때만 디스크를 액세스 하므로 논리적 블록 I/O 중 일부를 물리적으로 I/O(액세스 Arm).
    - SQL을 실행할 때마다 다름 -> 연속 실행시 I/O가 줄어듬 -> DB 버퍼 캐시에 해당 테이블 블록 점유율이 높아지기 때문
- 버퍼 캐시 히트율
  - BCHR : Buffer Cache Heat Ratio
  - 읽은 전체 블록 중 물리적인 디스크 I/O를 수반하지 않고 곧바로 메모리에서 찾은 비율
  - 물리적 I/O가 성능을 결정하지만 실제 SQL 성능을 향상하려면 논리적 I/O를 줄여야 함.
    -> 물리적 I/O는 결국 시스템 상황에 의해 결정되는 통제 불가능한 외생변수이기 때문
  - 논리적 I/O를 줄이는 방법 : SQL을 튜닝해서 읽는 총 블록 개수를 줄이자!
  - 실제 계산
    Query + Current = DB 버퍼캐시에서 읽은 총 블록 개수: 즉 디스크I/O + 논리적I/O
- Single Block I/O vs. Multiblock I/O
  - 캐시에서 찾지 못한 데이터 블록은 I/O 콜을 통해 디스크에서 DB 버퍼 캐시에 적제 
    -> 이 때 적재할 때 한블록/여러블록 으로 나뉨
  - Single Block I/O: 인덱스, 테이블 블록 (소량 데이터를 읽을 때)
    1) 인덱스 루트 블록
    2) 인덱스 루트 블록에서 얻은 주소로 브랜치 블록 읽을 때
    3) 브랜치 블록에서 얻은 주소로 리프 블록을 읽을 때
    4) 리프 블록에서 얻은 주소로 테이블 블록을 읽을 때
  - Multiblock I/O: 인덱스 사용하지 않고 테이블 전체 스캔시(대량 데이터 읽을 때)
    - 잠자는 횟수를 줄이고 성능을 높이기 위해 대용량 처리시 필요
    - 디스크 상에 블록과 인접한 블록(같은 익스턴트 내에 있는 블록)들을 한꺼번에 읽어 캐시에 미리 적재(1MB 씩)
    - db_file_multiblock_read_count 파라미터 : 적재할 양을 정하는 파라미터
      : OS 레벨 I/O 단위 1MB, 오라클 레벨 단위 8KB
    - 익스턴트 경계를 넘지는 못함
- Table Full Scan vs. Index Range Scan
  - Table Full Scan: 시퀀설 액세스와 Multiblock I/O 방식으로 디스크 블록 읽음
    - 캐시에서 못찾으면 한번의 수면(I/O call)으로 인접한 수십~수백개 블록 한번에 I/O
    - 스토리지 스캔 성능이 좋아지면 같이 성능 좋아짐
    - 대용량에 유리
  - Index Range Scan: 인덱스를 이용한 테이블 스캔
    - 랜덤 액세스와 Single Block I/O사용
    - 일정량을 스캔하면서 얻은 ROWID로 테이블 레코드를 찾아가는 방식
    - 소용량에 유리
- 캐시 탐색 매커니즘
  - 메모리 버퍼 캐시: Direct Path I/O를 제외한 모든 블록 I/O가 경유
    - Single Block I/O 상황 4가지 + Full Scan 할 때
    - 해시 구조로 관리
      1) 같은 입력 값은 항상 동일한 해시체인(버킷)에 연결
      2) 다른 입력값이 동일한 해시 체인에 연결될 수 있음
      3) 해시 체인 내에서 정렬 보장 X
  - 액세스 직렬화
    - 버퍼 캐시는 SGA에 속하므로 공유되는 자원 -> 동시에는 접근 못함 -> 순차적으로 접근하도록 직렬화 매커니즘 구현
    - 래치 : 줄서기가 가능하도록 지원하는 매커니즘, Lock과 비슷한 역할이지만 더 짧고 경량화 된 lock 
      - 캐시 버퍼 체인 래치 : Buffer Cache 블록 체인 접근 보호
      




* 인덱스 루트 블록 주소 : SQL 파싱하고 최적화하는 시점에 SQL 커서에 담김




