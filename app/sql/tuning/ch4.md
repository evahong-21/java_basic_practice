4. 조인 튜닝

4.1 NL 조인(Nested Loop - 중첩루프문)
- 조인의 기본
- 인덱스 이용한 조인
    - outer 조인은 풀스캔을 해도 한번, but inner쪽 테이블은 인덱스 사용
    - ordered use_nl(table)
        ordered : From 절에 기술한 순서대로 조인
        use_nl : NL방식으로 조인
    - select /*+ ordered use_nl(B) use_nl(C) use_hash(D) */ * from A, B, C, D
        A -> B -> C -> D 순서로 조인
        B,C 는 NL 방식 조회, D는 해시조인
    - leading(C, A, D, B) : From 절을 바꾸지 않고 순서 제어 가능
    - use_nl(A, B, C, D) : NL방식으로 조인하되 순서는 옵티마이저가 스스로 정함
    - index(테이블) : 어떤 인덱스를 사용할지 인덱스명 명시되어 있지 않으면 존재하는 인덱스 중 옵티마이저가 선택
- NL 조인 튜닝 포인트
    조인 액세스 횟수, 테이블 랜덤 액세스 횟수
    각 단계의 수행 일량을 부석해서 과도한 랜덤 액세스가 발생하는 지점 우선 파악
    NL 조인으로 좋은 성능을 내가 어렵다 판단(테이블 간 조인순서를 변경) -> 소트머지조인/해시조인 검토
- NL 조인 특징
    1. 랜덤 액세스 위주의 조인방식 : 인덱스 구성이 완벽해도 대량 데이터 조인 시 불리
    2. 한 레코드씩 순차적으로 진행 : 이 특징이 첫번째 특징을 상쇄 -> 부분범위 처리가 가능한 상황에서 성능 좋음
    3. 인덱스 구성 전략이 특히 중요 
    4. 온라인 트랜잭션 처리(OLTP) 시스템에 적합 : 소량 데이터, 부분범위 처리 
- NL 조인 튜닝 실습
    오라클 : cr - 논리적인 블록 요청 횟수/ pr - 디스크에서 읽은 블록수 / pw - 디스크에 쓴 블록 수
- NL 조인 확장 매커니즘
    테이블 Prefetch, 배치 I/O기능 : 오라클이 NL 조인 성능을 높이기 위해 도입
    두 기능 모두 읽는 블록마다 I/O Call 발생시키는 비효율을 줄이기 위해 고안
    1. 테이블 Prefetch : 인덱스를 이용해 테이블을 액세스 하다가 디스크 I/O가 필요해지만 이어서 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재
    2. 배치 I/O기능 : 디스크 I/O Call 을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리하는 기능

4.2 소트 머지 조인
- 조인 컬럼에 인덱스가 없을 떄, 대량 데이터 조인으로 인덱스의 효과가 없을 떄 
- 해시 조인이 등장하고 조금 밀렸지만 해시조인을 사용할 수 없는 상황에서 대량 데이터 조인할 떄 유용
- SGA vs PGA
    SGA : 공유 메모리 영역
        동시에 액세스 하려는 프로세스 간 액새스 직렬화 하기 위해 Lock 매커니즘으로 래치(Letch)가 존재
    PGA(Process/Program/Private) : 고유 메모리 영역
        독립적인 메모리 공간으로 래치 매커니즘 불필요
        같은 양의 데이터 읽을 떄 훨씬 빠름
        PGA에 공간 없을 떄 TEMP테이블 스페이스 사용(디스크에 쓴다)
- 기본 매커니즘 
    1. 소트 단계: 양쪽 집합을 조인 컬럼 기준으로 정렬
    2. 머지 단계: 정렬한 양쪽 집합을 서로 머지
    - use_merge: 소트 머지 조인 힌트
    조인하는 컬럼 기준으로 두 테이블을 sort하여 PGA 저장 후 NL조인
    Sort Area에 저장한 데이터 자체가 인덱스 역할 -> 조인 컬럼에 인덱스가 없어도 사용 가능
- 소트 머지 조인이 빠른 이유
    NL 조인: '인덱스를 이용한 조인 방식' -> 조인 과정에서 액세스 하는 모든 블록을 건건이 DB 버퍼캐시를 경유해서 읽음
    -> 읽는 모든 블록에 래치 획득 및 캐시버퍼 체인 스캔과정 -> 버퍼캐시에서 못읽은 블록은 건건이 디스크에서 읽음
    -> 인덱스 손익분기점 한계 -> 대량 데이터 조인에 NL 조인이 불리한 이유
    소트 머지 조인: 조인 대상 집합을 일괄적으로 읽어 PGA에 저장 후 조인 -> 래치 획등 과정 X -> 대량 데이터 조인에 유리
- 소트 머지 조인의 주용도
    해시 조인의 등장으로 특정 조건에서 주로 사용
    1. 조인 조건식이 등치(=)조건이 아닌 대량 데이터 조인
    2. 조인 조건식이 아예 없는 조인(Cross join/카테시안 곱)
- 소트 머지 조인 특징 요약
    소트 부하만 감수한다면 건건이 버퍼캐시를 경유하는 NL 조인보다 빠름
    스캔 위주의 액세스 방식, but 모든 처리가 스캔 방식으로 이루어지지 않음
    -> 양쪽 소스 집합으로부터 조인 대상 레코드를 찾는데 인덱스 사용 -> 랜덤 액세스 일어남(해시 조인 동일)

4.3 해시조인
- 소트머지조인은 항상 양쪽 테이블을 정렬하는데 부담 > 해시조인은 한쪽을 읽어 해시맵 생성 -> 부담 없음
    즉, 오퍼레이션을 시작하기 전 사전 준비작업에서 성능 차이 발생

- 두 단계
    1. Build 단계 : 작은쪽 테이블(Build Input)을 읽어 해시 테이블(해시맵)을 생성
    2. Probe 단계 : 큰 쪽 테이블(Probe Input)을 읽어 해시 테이블을 탐색하면서 조인
- use_hash : hash맵 적용할 테이블
- 해시 조인이 빠른 이유
    조인 프로세싱 자체는 NL조인과 같지만 래치 획득과정 없이 PGA에서 빠르게 데이터 탐색&조인 하기 떄문
    TEMP에 저장되어도 보통은 소트머지조인보다 대용량 처리 시 성능 좋음
- 대용량 BUILD Input 처리 : 분할&정복 방식 (Divide&Conquer)
    1. 파티션 단계 : 조인할 컬럼에 해시함수 적용 -> 반환된 해시값에 동적으로 파티셔닝 -> 파티셔 짝(pair)을 생성하는 단계
        양쪽 집합을 읽어 디스크 Temp공간에 저장하므로 인메모리 해시 조인보단 성능이 많이 떨어짐
    2. 조인 단계 : 파티션 짝(pair)에 대해 하나씩 조인 수행 -> Build Input과 Probe Input은 독립적으로 결정
        파티션 하기 전 크기와 상관 없이 파티션 별로 작은쪽을 Build Input으로 선택
- swap_join_inputs : Build Input을 직접 선택
- no_swap_join_input : Probe Input을 직접 선택(oracle 10.1.0.3 버전^)
    그 이전 버전에서 T1,T2 조인한 결과 집합을 Build Input으로 사용하고 싶을 때 -> 인라인뷰 Alias로 제어
- leading, ordered : 지시한 순서에 따라 먼저 읽는 테이블을 Build Input으로 선택
- 조인 메소드 선택 기준
    1. 소량 뎅터 조인:NL조인 / 대량 데이터 조인:해시조인 / 조인조건식이 등치가 아닐때(카테시안곱 포함):소트머지조인
    2. 소량/대량 기준 : NL조인 기준으로 최적화했는데도 랜덤 액세스가 많아 만족할만한 성능이 아닌경우 -> 대량 데이터 조인임
    3. 최적화된 NL조인과 해시조인 성능이 같다면:NL조인/해시조인이 약간 더 빨라:NL조인/NL조인보다 해시조인이 매우 빠를 떄:해시조인
        NL조인에 사용되는 인덱스는 영구적으로 유지하면서 다양한 쿼리를 위해 공유 및 재사용
        but, 해시테이블은 단 하나의 쿼리를 위해 생성하고 끝나면 곧바로 소멸하는 자료구조
    4. 해시조인의 세가지 조건: 수행빈도가 낮고/쿼리 수행시간이 오래 걸리는/대량 데이터 조인할 때

4.4 서브쿼리 조인
- 서브쿼리 변환이 필요한 이유