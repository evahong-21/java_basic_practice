4. 조인 튜닝

4.1 NL 조인(Nested Loop - 중첩루프문)
- 조인의 기본
- 인덱스 이용한 조인
    - outer 조인은 풀스캔을 해도 한번, but inner쪽 테이블은 인덱스 사용
    - ordered use_nl(table)
        ordered : From 절에 기술한 순서대로 조인
        use_nl : NL방식으로 조인
    - select /*+ ordered use_nl(B) use_nl(C) use_hash(D) */ * from A, B, C, D
        A -> B -> C -> D 순서로 조인
        B,C 는 NL 방식 조회, D는 해시조인
    - leading(C, A, D, B) : From 절을 바꾸지 않고 순서 제어 가능
    - use_nl(A, B, C, D) : NL방식으로 조인하되 순서는 옵티마이저가 스스로 정함
    - index(테이블) : 어떤 인덱스를 사용할지 인덱스명 명시되어 있지 않으면 존재하는 인덱스 중 옵티마이저가 선택
- NL 조인 튜닝 포인트
    조인 액세스 횟수, 테이블 랜덤 액세스 횟수
    각 단계의 수행 일량을 부석해서 과도한 랜덤 액세스가 발생하는 지점 우선 파악
    NL 조인으로 좋은 성능을 내가 어렵다 판단(테이블 간 조인순서를 변경) -> 소트머지조인/해시조인 검토
- NL 조인 특징
    1. 랜덤 액세스 위주의 조인방식 : 인덱스 구성이 완벽해도 대량 데이터 조인 시 불리
    2. 한 레코드씩 순차적으로 진행 : 이 특징이 첫번째 특징을 상쇄 -> 부분범위 처리가 가능한 상황에서 성능 좋음
    3. 인덱스 구성 전략이 특히 중요 
    4. 온라인 트랜잭션 처리(OLTP) 시스템에 적합 : 소량 데이터, 부분범위 처리 
- NL 조인 튜닝 실습
    오라클 : cr - 논리적인 블록 요청 횟수/ pr - 디스크에서 읽은 블록수 / pw - 디스크에 쓴 블록 수
- NL 조인 확장 매커니즘
    테이블 Prefetch, 배치 I/O기능 : 오라클이 NL 조인 성능을 높이기 위해 도입
    두 기능 모두 읽는 블록마다 I/O Call 발생시키는 비효율을 줄이기 위해 고안
    1. 테이블 Prefetch : 인덱스를 이용해 테이블을 액세스 하다가 디스크 I/O가 필요해지만 이어서 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재
    2. 배치 I/O기능 : 디스크 I/O Call 을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리하는 기능


4.2 소트 머지 조인
- 조인 컬럼에 인덱스가 없을 떄, 대량 데이터 조인으로 인덱스의 효과가 없을 떄 
- 해시 조인이 등장하고 조금 밀렸지만 해시조인을 사용할 수 없는 상황에서 대량 데이터 조인할 떄 유용
- SGA vs PGA
    SGA : 공유 메모리 영역
        동시에 액세스 하려는 프로세스 간 액새스 직렬화 하기 위해 Lock 매커니즘으로 래치(Letch)가 존재
    PGA(Process/Program/Private) : 고유 메모리 영역
        독립적인 메모리 공간으로 래치 매커니즘 불필요
        같은 양의 데이터 읽을 떄 훨씬 빠름
        PGA에 공간 없을 떄 TEMP테이블 스페이스 사용(디스크에 쓴다)
- 기본 매커니즘 
    1. 소트 단계: 양쪽 집합을 조인 컬럼 기준으로 정렬
    2. 머지 단계: 정렬한 양쪽 집합을 서로 머지
    - use_merge: 소트 머지 조인 힌트
    조인하는 컬럼 기준으로 두 테이블을 sort하여 PGA 저장 후 NL조인
    Sort Area에 저장한 데이터 자체가 인덱스 역할 -> 조인 컬럼에 인덱스가 없어도 사용 가능
- 소트 머지 조인이 빠른 이유
    NL 조인: '인덱스를 이용한 조인 방식' -> 조인 과정에서 액세스 하는 모든 블록을 건건이 DB 버퍼캐시를 경유해서 읽음
    -> 읽는 모든 블록에 래치 획득 및 캐시버퍼 체인 스캔과정 -> 버퍼캐시에서 못읽은 블록은 건건이 디스크에서 읽음
    -> 인덱스 손익분기점 한계 -> 대량 데이터 조인에 NL 조인이 불리한 이유
    소트 머지 조인: 조인 대상 집합을 일괄적으로 읽어 PGA에 저장 후 조인 -> 래치 획등 과정 X -> 대량 데이터 조인에 유리
- 소트 머지 조인의 주용도
    해시 조인의 등장으로 특정 조건에서 주로 사용
    1. 조인 조건식이 등치(=)조건이 아닌 대량 데이터 조인
    2. 조인 조건식이 아예 없는 조인(Cross join/카테시안 곱)
- 소트 머지 조인 특징 요약
    소트 부하만 감수한다면 건건이 버퍼캐시를 경유하는 NL 조인보다 빠름
    스캔 위주의 액세스 방식, but 모든 처리가 스캔 방식으로 이루어지지 않음
    -> 양쪽 소스 집합으로부터 조인 대상 레코드를 찾는데 인덱스 사용 -> 랜덤 액세스 일어남(해시 조인 동일)


4.3 해시조인
- 소트머지조인은 항상 양쪽 테이블을 정렬하는데 부담 > 해시조인은 한쪽을 읽어 해시맵 생성 -> 부담 없음
    즉, 오퍼레이션을 시작하기 전 사전 준비작업에서 성능 차이 발생

- 두 단계
    1. Build 단계 : 작은쪽 테이블(Build Input)을 읽어 해시 테이블(해시맵)을 생성
    2. Probe 단계 : 큰 쪽 테이블(Probe Input)을 읽어 해시 테이블을 탐색하면서 조인
- use_hash : hash맵 적용할 테이블
- 해시 조인이 빠른 이유
    조인 프로세싱 자체는 NL조인과 같지만 래치 획득과정 없이 PGA에서 빠르게 데이터 탐색&조인 하기 떄문
    TEMP에 저장되어도 보통은 소트머지조인보다 대용량 처리 시 성능 좋음
- 대용량 BUILD Input 처리 : 분할&정복 방식 (Divide&Conquer)
    1. 파티션 단계 : 조인할 컬럼에 해시함수 적용 -> 반환된 해시값에 동적으로 파티셔닝 -> 파티셔 짝(pair)을 생성하는 단계
        양쪽 집합을 읽어 디스크 Temp공간에 저장하므로 인메모리 해시 조인보단 성능이 많이 떨어짐
    2. 조인 단계 : 파티션 짝(pair)에 대해 하나씩 조인 수행 -> Build Input과 Probe Input은 독립적으로 결정
        파티션 하기 전 크기와 상관 없이 파티션 별로 작은쪽을 Build Input으로 선택
- swap_join_inputs : Build Input을 직접 선택
- no_swap_join_input : Probe Input을 직접 선택(oracle 10.1.0.3 버전^)
    그 이전 버전에서 T1,T2 조인한 결과 집합을 Build Input으로 사용하고 싶을 때 -> 인라인뷰 Alias로 제어
- leading, ordered : 지시한 순서에 따라 먼저 읽는 테이블을 Build Input으로 선택
- 조인 메소드 선택 기준
    1. 소량 데이터 조인:NL조인 / 대량 데이터 조인:해시조인 / 조인조건식이 등치가 아닐때(카테시안곱 포함):소트머지조인
    2. 소량/대량 기준 : NL조인 기준으로 최적화했는데도 랜덤 액세스가 많아 만족할만한 성능이 아닌경우 -> 대량 데이터 조인임
    3. 최적화된 NL조인과 해시조인 성능이 같다면:NL조인/해시조인이 약간 더 빨라:NL조인/NL조인보다 해시조인이 매우 빠를 떄:해시조인
        NL조인에 사용되는 인덱스는 영구적으로 유지하면서 다양한 쿼리를 위해 공유 및 재사용
        but, 해시테이블은 단 하나의 쿼리를 위해 생성하고 끝나면 곧바로 소멸하는 자료구조
    4. 해시조인의 세가지 조건: 수행빈도가 낮고/쿼리 수행시간이 오래 걸리는/대량 데이터 조인할 때


4.4 서브쿼리 조인
- 서브쿼리 변환이 필요한 이유
    1. 인라인 뷰 : from절에 사용한 서브쿼리
    2. 중첩된 서브쿼리(Nested) : 결과 집합을 한정하기 우해 Where 절에 사용한 서브쿼리
        서브쿼리가 메인쿼리 컬럼을 참조하는 형태: 상관관계 있는 서브쿼리
    3. 스칼라 서브쿼리(Scalar) : 한 레코드당 정확히 하나의 값을 반환하는 서브쿼리
        주로 Select-list에서 사용하지만 몇가지 예외사항 제외 컬럼이 올수 있는 대부분 위치에 사용가능
- 쿼리 변환 : 옵티마이저가 sql을 분석해 의미적으로 동일하면서 더 나은 성능이 기대되는 형태로 재작성
    서브쿼리별로 최적화한 쿼리가 전체적으로 최적화 X -> 나무가 아닌 숲 전체 관점에서 서브쿼리 풀기
- 1) 서브쿼리와 조인
    서브쿼리는 메인쿼리에 종속 -> 단독 실행 불가 -> 메인쿼리 건수만큼 반복적으로 필터링 방식
    - 필터 오퍼레이션 : NL조인과 처리 루틴이 동일
        첫번째 차이점 : 필터는 메인의 한 로우가 서브의 한 로우와 조인에 성공하면 진행 멈춤 -> 메인의 다음 로우 처리
        두번째 차이점 : 필터는 캐싱 기능 존재 -> 필터 결과 서브쿼리 입력값에 따른 true/false 값을 캐싱
            캐싱은 쿼리 단위로 이뤄짐 : 쿼리 시작 -> PGA메모리에 공간 할당 -> 쿼리수행 공간채움 -> 쿼리 종ㄹ료 공간 반환
        마지막 차이점 : 일반NL조인과 달리 메인쿼리에 종속 -> 조인순서 고정 -> 힌트를 써도 변경되지 않음
    - no_unnest : 서브쿼리를 풀어내지 말고 그대로 수행하라는 힌트(필터 방식으로 처리 의도) 
        rownum 사용하면 위 힌트와 같은 기능을 갖음
    - unnest : 중첩된 상태를 풀어내라 -> 메인과 서브쿼리간의 계층구조를 풀어 서로 같은 레벨로 만듬(서브쿼리 Flattening)
        일반 조인문처럼 다양한 최적화 기법 사용 가능
            옵티마이저는 많은 조인 테크닉을 갖고 있으므로 필터 오퍼레이션보다 더 좋은 실행경로를 찾을 가능성 높음
    - nl_sj : NL 세미조인 방식으로 실행
        기본적으로 NL조인과 같은 프로세스 -> 조인에 성공하는 순간 진행 멈추고 다음 로우 처리가 차이점
    - hash_sj : 해시 세미 조인
    - ROWNUM 잘쓰기!!
        서브쿼리를 Unnesting하면 필터 오퍼레이션보다 더 좋은 실행경로 찾을 가능성 큼 -> 
        but, 서브쿼리에 rownum을 쓰면 이 옵티마이징 기능을 사용하지 못하게 막음.(이 서브쿼리 블록은 손대지 말라)
        - 서브쿼리에 함부로 쓰지 않는다!
    - 서브쿼리 Pushing
        push_sub : 서브쿼리 필터링을 먼저 처리 후 조인단게 진행
         Unnesting되지 않은 서브쿼리에만 작동 -> 항상 no_unnest힌트와 같이 사용
        no_push_subq : 서브쿼리 필터링을 가능한 나중에 처리하기 위한 힌트 -> no_unnest 힘트와 같이 사용
- 2) 뷰와 조인
    최적하 단위가 쿼리 블록이므로 옵티마이저가 뷰 쿼리를 변환하지 않으면 뷰쿼리 블록 독립적으로 최적화
    merge : 뷰를 메인 쿼리와 머징
    no_merge : 뷰 머징 방지
    - 조인 조건 Pushdown(11g 이후) : 메인 쿼리 실행하면서 조건 조건절 값을 건건이 뷰 안으로 밀어넣는 기능
        push_pred 힌트 : 부분범위 처리 가능
            옵티마이저가 뷰를 머징하면 힌트가 작동하지 않으니 no_merge 힌트와 함께 사용
    - Lateral 인라인 뷰, Cross/Outer Apply 조인(12c 이상)
        - 기본적으로 쓸 이유는 없음! 튜닝 과정에서 알수없는 이유로 조인조건 pushdown 기능이 동작하지 않을 때 활용
        원래 인라인 뷰에서 메인쿼리 테이블 참조하면 00904 에러 발생
        Lateral 인라인 뷰 : 인라인 뷰 괄호 앞에 LATERAL 선언하면 메인쿼리 테이블 컬럼 참조 가능
            Outer 조인 : 인라인 뷰 괄호 뒤에 (+) 추가
        Outer Apply 조인
        Cross Apply 조인
- 3) 스칼라 서브쿼리 조인
    메인 쿼리 레코드마다 정확히 하나의 값만 반환
    outer 조인문처럼 NL 조인 방식으로 실행 -> 차이는 스칼라는 처리과정에서 캐싱작용 발생
    부분 범위 처리 가능
    두개 이상의 값을 반환하고 싶을 땐 그냥 인라인 뷰 사용하자(조인조건 pushdown 기능으로 보완)
    - 스칼라 서브쿼리 캐싱 
        조인 시 횟수를 최소화하기 위해 입력값, 출력값을 내부 캐시(query execution cache)에 저장(쿼리단위로)
        함수에 스칼라 서브쿼리를 덧씌우면 호출 횟수를 최소화 함
        부작용 : 입력값이 종류가 소수라서 해시 충돌 가능성이 작을 때 효과 -> 반대의 경우 캐시를 매번 확인하는 비용으로 오히려 성능 저하
            메인쿼리 집합이 매우 작을떄 : 메인쿼리 집합이 클수록 캐시 재사용성 높아 효과가 크지만 반대는 재사용성도 낮다.
    - 스칼라 서브쿼리 Unnesting