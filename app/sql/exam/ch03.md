2/1/4/1/?/?/2/4/2/1/
2/3/4/3/1/2/3/4/4/2/
2/2/2/1/1/4/주관식

# 인덱스 기본원리
4. Index 힌트
- INDEX (table_nm (column,(콤마생략가능) column)) 에서 기존에 생성된 인덱스 순서에 맞지 않으면 힌트가 무시된다.

5. INDEX 힌트 - With절, OPTION절, INDEX(n)
1) WITH 절
    - FROM table_nm WITH(INDEX(index_nm))
    - FROM table_nm WITH(INDEX=index_nm)
    - FROM table_nm WITH(FORCESEEK(index_nm(column_nm)))
2) INDEX(n)
* 클러스터형 인덱스가 있을 떄
- FROM table_nm WITH(INDEX(1)) : 클러스터형 인덱스를 검색
                    (INDEX(0)) : 클러스터형 인덱스를 Scan하면서 column 필터링
* 클러스터형 인덱스가 없을 떄
- FROM table_nm WITH(INDEX(1)) : 구문오류 발생
                    (INDEX(0)) : 테이블을 Full Scan하면서 조건절을 필터링 
3) OPTION절
- OPTION (TABLE HINT(table_nm, INDEX(index_nm)))

6. INDEX 힌트 - FORCESCAN
- FORCESCAN : 조건을 검색하지 않고 FUll Scan하면서 필터링

19. 인덱스를 이용한 랜덤액세스 줄이는 방법
1) IOT : 테이블을 인덱스 구조로 관리, 지정한 키 값 순으로 정렬상태 유지 -> 테이블 랜덤 액세스가 전혀 발생하지 X
2) 클러스터 : 같은 레코드를 한 블록에 모아 저장 -> 인덱스를 이용한 테이블 랜덤 액세스를 줄이는데 도움
3) 테이블 파티션 : 사용자가 지정한 기준에 따라 데이터를 세그먼트 단위로 모아서 저장 
    -> 특정 조건 만족하는 데이터를 인덱스 랜덤 액세스가 아닌 Full Scan방식으로 빠르게 찾음

20. IOT
- PK순으로 정렬 상태를 유지하는 테이블: 일반 속성이 없고 PK 3개인 테이블을 IOT 로 구성하면 별도 PK 인덱스를 생성하지 X
- A 순으로 정렬되도록 IOT를 구성하면 조회하는 쿼리 성능 향상(ex. 일자순으로 정렬되게 IOT구성)
- 한 건씩 조회하는건 데이터를 모아서 저장하는데 따른 이점을 얻을 수 없음
- PK이외의 속성이 많으므로 향상 떨어짐

22. INDEX RANGE SCAN 불가 조건
- 인덱스 스캔 시작점을 찾을 수 있어야 한다 -> 시작지점과 끝지점이 있어야 한다.
- 인덱스 액세스 조건 컬럼을 조건절에서 가공하면 안됨.
- 양쪽 % LIKE 조건 불가 / 부정형 비교 조건 불가 / SUBSTR() 불가
- 수직적 탐색이 가능할 땐 Range Scan 가능 : 업체명 = NVL(:VAL, '대한')
    - 옵션조건 : 업체명 = NVL(:VAL, 업체명) > OR Expansion(Union All 로 자동 쿼리변환) 여부에 따라 range scan 가능 여부 결정

23. IS NULL 조건에 대한 Index Range Scan
- 오라클은 구성컬럼이 모두 NULL 인 레코드는 인덱스에 저장하지 않음 
- 단일 컬럼에 생성한 인덱스에 대한 IS NULL 조건으로는 Index Range Scan 불가
- 2개이상 구성된 결합 인덱스에 대해선 IN NULL 조건에 대해 가능 > 구성 컬럼중 하나라도 NULL이 아닌 레코드는 인덱스에 저장하기 떄문
    - 인덱스의 두 구성컬럼이 모두 NULL을 허용하면 테이블 레코드보다 인덱스 레코드가 적다
        > A, B 모두 널인 데이터는 인덱스에 저장하지 않기 때문 > A IS NULL 조건으로 Index Range Scan시 결과 집합에서 누락될 수 있음

24. Index Range Scan 가능한 경우
- 선두조건 인덱스 조건문이 자동 형변환 > 불가 : 가공한 컬럼
- 인덱스 구성 컬럼이 모두 NULL 일 떄 > 불가 : 두 값이 모두 NULL인 데이터는 인덱스에 저장되지 않으므로 결과집합에 누락
- 인덱스의 선두 컬럼이 조건절에 있어야 함

26. OR 조건에 대한 Index Range Scan
- OR 조건은 기본적으로 Index Range Scan을 위한 액세스 조건으로 사용할 수 없음
    > OR 조건으로는 수직적 탐색을 통해 스캔 시작점을 찾을 수 없음
- CONCATENATION: 옵티마이저에 의한 Union All 분기 > 각각 수직 탐색으로 탐색할 액세스 조건으로 사용할 인덱스가 있으면 가능하게 함
    > 다른 조건절 조건으로 인해 어쩌피 Full Scan을 해야한다면 Union All 하지 않고 그냥 함
    - use_concat으로 Union All 분기를 강제할 수 있음
    - where cust_no is null or 고객번호= :cust_no 일 땐 use_concat 힌트도 들지 않음.

# 테이블 액스 최소화
1/4/2/3/2/4/3/3/3/

34. 손익분기점
- CF가 좋으면 테이블 블록 I/O가 감소하므로 소요시간이 준다 > '인덱스 ROWID를 이용한 테이블 액세스' 경사가 완만해지면서 인덱스 손익분기점이 올라간다
    > 그래프에서 우측으로 이동
- Multiblock I/O를 늘리면 디스크 I/O call 횟수가 줄고 테이블 전체 스캔 비용이 낮아진다 > 소요시간 준다 > 인덱스 손익분기점이 내려간다
- 테이블 스캔 비용은 데이터 양이 느는만큼 선형적으로 증가하지만 인덱스를 이용한 테이블 액세스 비용은 데이터양이 늘고 추출 건수가 많아질수록 기하급수적으로 증가

37. 테이블 랜덤 액세스 줄이는 방향
- 인덱스 컬럼 추가를 가장 우선해서 검토
- IOT가 테이블 랜덤 액세스를 없애는데 가장 효과적 > 다만 테이블 구조 변경 부담, IOT 자체가 갖는 부작용 존재
- 테이블을 인덱스 정렬하여 재생성한다.
- 인덱스 재구성 시 인덱스 스캔 비효율 줄이는데 도움 > but 테이블 랜덤액세스 줄이는데 도움 X

38. 인덱스에 컬럼을 추가한다면?
- 인덱스 사이즈 증가,
- 인덱스 높이 증가 > 한 블록에 담을 수 있는 로우 수가 줄면 리프 블록 수가 증가
- 리프 블록수가 증가하면 스캔 과정에 읽는 블록 I/O 증가 > 스캔 효율 나빠짐
- 뒤쪽에 컬럼을 추가하면 새로운 정렬 순서를 갖게 되므로 클러스터링 팩터가 나빠진다

39~40. 배치 I/O
- 읽는 블록마다 건건이 I/O Call을 발생시키는 비효율을 줄이기 위해 고안한 기능
- 인덱스를 이용해 테이블을 액세스 하다가 버퍼 캐시에서 블록을 찾지 못하면 디스크I/O 콜을 미뤘다가 읽은 블록이 일정량 쌓이면 한꺼번에 처리한다 
    > 버퍼 캐시에서 읽는 블록수는 동일하다
    > 테이블 랜덤 액세스 과정에 발생하는 디스크 I/O 성능이 좋아진다
- 이 기능을 작동하면 정렬순서가 매번 다를 수 있음
- Sort Order By 오퍼레이션이 되지 않은 배치 기능은 부분범위 처리가 가능하다 -> 전체 정렬을 할 필요 없기 때문
    > 전체 정렬을 하는 순간 부분범위 처리 불가

# 인덱스 스캔 효율화
?/1/2,3/3/2/1/4/주/주/?
4/3

41. 인덱스 튜닝의 두가지 핵심요소
1) 인덱스 스캔과정 비효율 줄이기: 인덱스를 스캔한 양에 비해 얻은 결과 건수가 적으면 비효율적
2) 테이블 액세스 횟수 줄이기: 테이블 액세스한 양에 비해 얻은 결과의 수가 적으면
- 즉 cr로 읽은 블록 수보다 row수가 월등히 적으면 비효율 / row 수가 더 많으면 효율적

42. 인덱스 스캔 효율
- 테이블과 달리 인덱스는 같은값을 갖는 레코드들이 서로 군집
- 인덱스 선행 컬럼이 조건절에 없거나, 범위검색 조건이면 비효율이 일어난다
- 인덱스 뒤쪽 컬럼일 땐 범위 검색이어도 비효율이 없다.

44. **진짜어려움**
- 조건문으로 걸러지는게 많은 컬럼이 선두컬럼이면 I/O가 줄어들 것.
- 인덱스 선두 컬럼이 BETWEEN 조건에서 IN 조건으로 처리하는건 성능에 도움 X 

47. IN 조건 처리 vs 필터 처리
- 선두 컬럼이라면 IN 조건을 IN-ist Iterator 방식으로 풀어야 Index Range Scan이 가능
- 후행 컬럼에서 필터 방식으로 처리하면 인덱스 높이가 3이면 3개 블록만 읽으면 됨 
    > 하지만 IN-LIST로 처리한다면 수직탐색 3번 * 인덱스 높이 3 = 9개 블록 읽어야함

50. 
- 선두컬럼이 범위 조건이면 후행 컬럼은 필터 조건일 수밖에 없으
    > 후행 컬럼은 어떻게 구현하든 성능에 차이 X
- 필터 조건에서 use_concat으로 CONCATENATION 방식이면 데이터를 반복적으로 읽음


# 인덱스 설계
