2/1/4/1/?/?/2/4/2/1/
2/3/4/3/1/2/3/4/4/2/
2/2/2/1/1/4/주관식


4. Index 힌트
- INDEX (table_nm (column,(콤마생략가능) column)) 에서 기존에 생성된 인덱스 순서에 맞지 않으면 힌트가 무시된다.

5. INDEX 힌트 - With절, OPTION절, INDEX(n)
1) WITH 절
    - FROM table_nm WITH(INDEX(index_nm))
    - FROM table_nm WITH(INDEX=index_nm)
    - FROM table_nm WITH(FORCESEEK(index_nm(column_nm)))
2) INDEX(n)
* 클러스터형 인덱스가 있을 떄
- FROM table_nm WITH(INDEX(1)) : 클러스터형 인덱스를 검색
                    (INDEX(0)) : 클러스터형 인덱스를 Scan하면서 column 필터링
* 클러스터형 인덱스가 없을 떄
- FROM table_nm WITH(INDEX(1)) : 구문오류 발생
                    (INDEX(0)) : 테이블을 Full Scan하면서 조건절을 필터링 
3) OPTION절
- OPTION (TABLE HINT(table_nm, INDEX(index_nm)))

6. INDEX 힌트 - FORCESCAN
- FORCESCAN : 조건을 검색하지 않고 FUll Scan하면서 필터링

19. 인덱스를 이용한 랜덤액세스 줄이는 방법
1) IOT : 테이블을 인덱스 구조로 관리, 지정한 키 값 순으로 정렬상태 유지 -> 테이블 랜덤 액세스가 전혀 발생하지 X
2) 클러스터 : 같은 레코드를 한 블록에 모아 저장 -> 인덱스를 이용한 테이블 랜덤 액세스를 줄이는데 도움
3) 테이블 파티션 : 사용자가 지정한 기준에 따라 데이터를 세그먼트 단위로 모아서 저장 
    -> 특정 조건 만족하는 데이터를 인덱스 랜덤 액세스가 아닌 Full Scan방식으로 빠르게 찾음

20. IOT
- PK순으로 정렬 상태를 유지하는 테이블: 일반 속성이 없고 PK 3개인 테이블을 IOT 로 구성하면 별도 PK 인덱스를 생성하지 X
- A 순으로 정렬되도록 IOT를 구성하면 조회하는 쿼리 성능 향상(ex. 일자순으로 정렬되게 IOT구성)
- 한 건씩 조회하는건 데이터를 모아서 저장하는데 따른 이점을 얻을 수 없음
- PK이외의 속성이 많으므로 향상 떨어짐

22. INDEX RANGE SCAN 불가 조건
- 인덱스 스캔 시작점을 찾을 수 있어야 한다 -> 시작지점과 끝지점이 있어야 한다.
- 인덱스 액세스 조건 컬럼을 조건절에서 가공하면 안됨.
- 양쪽 % LIKE 조건 불가 / 부정형 비교 조건 불가 / SUBSTR() 불가
- 수직적 탐색이 가능할 땐 Range Scan 가능 : 업체명 = NVL(:VAL, '대한')
    - 옵션조건 : 업체명 = NVL(:VAL, 업체명) > OR Expansion(Union All 로 자동 쿼리변환) 여부에 따라 range scan 가능 여부 결정

23. IS NULL 조건에 대한 Index Range Scan
- 오라클은 구성컬럼이 모두 NULL 인 레코드는 인덱스에 저장하지 않음 
- 단일 컬럼에 생성한 인덱스에 대한 IS NULL 조건으로는 Index Range Scan 불가
- 2개이상 구성된 결합 인덱스에 대해선 IN NULL 조건에 대해 가능 > 구성 컬럼중 하나라도 NULL이 아닌 레코드는 인덱스에 저장하기 떄문
    - 인덱스의 두 구성컬럼이 모두 NULL을 허용하면 테이블 레코드보다 인덱스 레코드가 적다
        > A, B 모두 널인 데이터는 인덱스에 저장하지 않기 때문 > A IS NULL 조건으로 Index Range Scan시 결과 집합에서 누락될 수 있음

24. Index Range Scan 가능한 경우
- 선두조건 인덱스 조건문이 자동 형변환 > 불가 : 가공한 컬럼
- 인덱스 구성 컬럼이 모두 NULL 일 떄 > 불가 : 두 값이 모두 NULL인 데이터는 인덱스에 저장되지 않으므로 결과집합에 누락
- 인덱스의 선두 컬럼이 조건절에 있어야 함

26. OR 조건에 대한 Index Range Scan
- OR 조건은 기본적으로 Index Range Scan을 위한 액세스 조건으로 사용할 수 없음
    > OR 조건으로는 수직적 탐색을 통해 스캔 시작점을 찾을 수 없음
- CONCATENATION: 옵티마이저에 의한 Union All 분기 > 각각 수직 탐색으로 탐색할 액세스 조건으로 사용할 인덱스가 있으면 가능하게 함
    > 다른 조건절 조건으로 인해 어쩌피 Full Scan을 해야한다면 Union All 하지 않고 그냥 함
    - use_concat으로 Union All 분기를 강제할 수 있음
    - where cust_no is null or 고객번호= :cust_no 일 땐 use_concat 힌트도 들지 않음.
