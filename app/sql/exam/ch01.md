TODO : 1-3 그림 그려보기, 저장/미저장 공간 오브젝트

1. DBMS 정의 (1장 - p18)
컨테이너: 
인스턴스: SGA 공유 메모리 영역과 이를 액세스 하는 프로세스 집합을 합친 것
데이터베이스: 디스크에 저장된 데이터 집합(Datafile, Redo Log File, Control File)
애플리케이션: 

RAC(Real Application Cluster)환경에서 하나의 데이터베이스에 여러 인스턴스가 연결 가능하지만, 하나의 인스턴스에 여러개 데이터베이스 연결 불가

2. 오라클 백그라운드 프로세스
SMON(System Monitor): 장애가 발생한 시스텝을 재기동할 떄 인스턴스 복구 수행, 임시 세그먼트와 익스텐드를 모니터링
PMON(Process Monitor): 이상이 생긴 프로세스가 사용하던 리소스를 복구
DBWn(Database Writer): 버퍼캐시에 있는 Dirty버퍼를 데이터파일에 기록
LGWR(Log Writer): 로그 버퍼 엔트리를 Redo로그 파일에 기록
ARCn(Archiver): 꽉 찬 Redo 로그가 덮어 씌이기 전에 Archive 로그 디랙토리로 백업
CKPT(Checkpoint): 이전에 checkpoint가 일어났던 마지막 시점 이후 데이터베이스 변경 사항을 데이터파일에 기록하도록 트리거링
RECO(Recoverer): 분산 트랜잭션 과정에 발생한 문제 해결

DML을 수행하는 각 사용자 프로세스 : 로그 버퍼에 로그 기록 > 데이터 블록 변경 > LGWR가 주기적으로 로그버퍼엔트리를 Redo 로그 파일에 기록

3. 데이터 저장 구조
블록(=페이지) : I/O 단위. 하나의 레코드에서 하나의 컬럼만 읽어도 그것이 속한 블록을 통채로 읽게 됨
익스텐트: 공간을 확장하는 단위, 데이블이나 인덱스에 데이터 입력하다가 공간이 부족함녀 해당 오브젝트가 속한 테이블 스페이스(물리적으로 데이터파일) 로 추가적인 공간 할당, 정해진 익스텐트 크기의 연속된 블록 할당
세그먼트: 익스텐트의 집합, 익스텐트 내의 블록은 논리적으로 인접하지만 익스텐트 끼리는 서로 인접하지 X
        데이터 저장공간을 사용하지 않는 오브젝트(테이블, 인덱스, 파티션, 클러스터, LOB)를
        저장공간을 사용하는 오브젝트(뷰, 시너님, 시퀀스, 함수, 프로시저, 트리거)
        와 구분해서 세그먼트라 지칭 -> 저장 공간을 사용한다는 것은 테이블 스페이스로부터 한 개 이상의 익스텐트를 할당받음
테이블 스페이스: 세그먼트를 담는 컨테이너. 각 세그먼트는 정확히 한 테이블 스페이스에만 속함. 한 세그먼트는 여러 데이터파일에 걸쳐 저장. 
        한 테이블 스페이스가 여러 데이터 파일로 구성되기 떄문

4. 데이터 저장구조.
- 실제 저장 공간을 필요로하는 오브젝트랑 아닌것들을 비교하자.
뷰: 쿼리 문장을 담고 있는 가상의 테이블 -> 데이터 딕셔너리에 미리 저장해 둔 쿼리 문장을 실행

5. 오라클이 Undo를 사용하는 목적(1장 - p40)

6. 

9. 오라클이 사용하는 메모리 캐시
- 1) DB 버퍼 캐시: 테이블 블록, 인덱스 블록, Undo 블록을 캐싱
- 2) 라이브러리 캐시: SQL, DB 저장형 함수/프로시저, 트리거를 캐싱
- 3) 딕셔너리 캐시: 테이블 정보, 인덱스 정보, 데이터파일 정보, 시퀀스 등 캐싱
- 4) Result 캐시: SQL 결과 집합을 캐싱

15. 옵티마이저 힌트가 무시되는 경우
- 문법적으로 맞지 않을 때
- 잘못된 참조 사용: 없는 테이블, 별칭, 인덱스명 지정
- 논리적으로 불가능한 액세스 경로 (조인절에 =가 없는데 해시조인, 테이블 전체 count 에 null 을 허용하는 단일컬럼으로 생성한 인덱스 사용)
- 의미적으로 맞지 않게 힌트(서브쿼리에 unnest와 push_subq를 같이 씀)
- 옵티마이저에 의해 내부적으로 쿼리가 변환된 경우
- SQL Server는 힌트에 오류가 있으면 컴파일 에러 발생, but 오라클은 발생 X

16. 옵티마이저 힌트 
- 힌트가 느슨하게 기술되어도 옵티마이저가 결정하여 적용
    ex) index힌트에 인덱스명 지정하지 않거나 leading 힌트에 나열하지 않은 테이블 조인 순서

18. 옵티마이저 힌트 외우기!!! 

19. 블록 단위 I/O
- 버퍼 캐시와 데이터파일 모두에 적용
- 딕셔너리 캐시: 데이터 딕셔너리에 저장된 테이블 및 컬럼 정보는 로우 단위로 I/O
    -> 딕셔너리 캐시를 로우 캐시라고 부르는 이유.

20. 
- 소트공간(Temp 테이블 스페이스)과 클라이언트에 전송량은 select 하는 컬럼 양에 따라 달라짐
- 블록 개수가 같을 때 : Table Full Scan & 인덱스 사용 시에도 특정 로우, 틀정 컬럼만 골라서 읽을 수 없음 
    -> 테이블 액세스 필요하므로 I/O 하는 블록은 같음.

23. 사용 빈도 높은 데이터 블록 버퍼캐시 알고리즘
- LPU(Least Recently Used): 가장 오래 사용되지 않은 데이터를 **먼저 제거(evict)**하는 방식
- MPU(Most Recently Used): 가장 최근에 사용된 데이터를 먼저 제거하는 방식

24. 시퀀셜 액세스 vs. 랜덤 액세스
- 인덱스를 스캔하면서 얻은 ROWID 로 테이블 블록 액세스 할 때 

25. Multiblock I/O
- db file sequential read 대기 이벤트: Single Block
- db file scattered read 대기 이벤트: Multiblock

27. 데이터베이스 I/O 원리
- 테이블 full scan: multi -> 익스텐트가 클수록 I/O call 적게 발생
- 인덱스 테이블 액세스 : sincle -> 익스텐트 크기에 I/O call이 영향받지 않음