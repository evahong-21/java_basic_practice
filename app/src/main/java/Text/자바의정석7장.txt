자바의정석 - 객체지향개념 7장
하나의 파일에서 public을 갖는 클래스는 단 하나여야함.


20강. 상속(Inheritance)
- 기존의 클래스로 새로운 클래스를 작성하는것(코드의 재사용)
- 두 클래스를 부모와 자식으로 관계를 맺어주는 것.
- 자손은 조상의 모든 멤버를 상속받는다. (생성자, 초기화블럭 제외)
- 자손의 멤버 개수는 조상보다 적을 수 없다.(무조건 같거나 많다) > 부모 멤버를 무조건 갖고 있어서. (포함관계)
- 자손의 변경은 조상에 영향을 미치지 않는다.



21강. 포함관계
- 포함이란 ? 클래스의 멤버로 참조변수를 선언하는것.
- 클래스의 관계는 1. 상속, 2.포함이 있음.

상속관계 : A는 B이다. (is)
	> extends 로 설정.
	> 상속받은 클래스의 참조변수만 사용.
포함관계 : A는 B를 갖고 있다. (has)
	> 클래스에 포함할 클래스 객체 생성. (new 사용)
	> 참조변수 2개 사용 후 변수 사용.



22강. 단일 상속(Single Inheritance)
- 자바는 단일 상속만을 허용한다. ( 다중 상속 허용하지 않음)
- 다중 상속의 역할을 자바에선 인터페이스로 사용함.
- 인터페이스를 사용 안하고 다중 상속을 사용하는 방법.
	> 비중이 높은 클래스 하나만 상속관계로, 나머지는 포함관계로 한다.

Object 클래스 : 모든 클래스의 조상.
- 부모가 없는 클래스 즉, 상속받지 않는 클래스는 자동적으로 Object클래스를 상속받게 된다.
- 모든 클래스는 Object 클래스에 정의된 11개의 메서드를 상속받는다. (ex. toString(), equals, hashCode)
- 우리가 작성하지 않아도 extends Object를 컴파일러가 자동 생성 함.



23강. 오버라이딩(overriding)
- 상속받은 조상의 메서드를 자신에 맞게 변경하는것.

조건
	1. 선언부가 조상 클래스의 메서드와 일치해야한다.
	2. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
		private, (default), protected, public
	3. 예외(8장)는 조상 클래스의 메서드보다 많이 선언할 수 없다.

오버로딩 : 기존에 없는 새로운 메서드를 정의하는것 > 이름은 같음 (상속과 관련 X)
오버라이딩 : 상속받은 메서드의 내용을 변경하는것.



24강. 참조변수 super, 조상의 생성자 super()
this와 super 모두 참조변수
- this : lv와 iv 구별에 사용.
- super : 조상멤버, 자신멤버 구별.
- 객체 자신을 가리키는 참조변수. 인스턴스 메서드(생성자)내에만 존재.
- 조상의 멤버를 자신의 멤버와 구별할 때 사용.

super()
- this() : 같은 클래스 내에서 생성자를 호출할 때 사용.
- 조상의 생성자를 호출할 때 사용.
- 조상의 멤버는 조상의 생성자를 호출해서 초기화.
- this()나 super() 둘중에 하나만 첫줄에 한번만 사용 가능
- 생성자의 첫 줄에 반드시 생성자(super() of this())를 호출해야한다.  ##### 중요
	> 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입.



25강. 패키지(packager)
- 서로 관련된 클래스의 묶음
- 클래스는 클래스파일, 패키지는 폴더, 하위 패키지는 하위 폴더.
- 클래스의 실제이름 (full name) 은 패키지를 포함(java.lang.String).
- rt.jar는 클래스들을 압축한 파일임. 저장된 클래스들을 모두 볼 수 있음.
	> (JDK설치경로\jre\lib에 위치) / jar파일은 jar.exe로 압축해제가능
	> Java 9 부터 rt.jar가 없어지고 module 개념이 대신함.

패키지의 선언
- 패키지는 소스파일의 첫번째 문장으로 단 한번 선언.
- 같은 소스 파일의 클래스들은 모두 같은 패키지에 속한다.
- 패키지 선언이 없으면 이름없는(unnamed) 패키지에 속하게 된다.
- class 파일을 java로 실행가능.

클래스 패스(classpath)
- 클래스파일의 위치를 알려주는 경로
- 환경변수 classpath로 관리하며, 경로간의 구분자는 ';'을 사용.
- 시스템변수 > 새로만들기 > 패키지루트(\bin)을 지정. > cmd 새로열기 
	set classpath : 저장되어 있는 클래스파일의 위치를 알려줌.



26강. import 문
- 클래스를 사용할 때 패키지이름을 생략할 수 있다.
- 컴파일러에게 클래스가 속한 패키지를 알려준다.
- java.lang 패키지는 자바의 핵심 클래스들이 있는 패키지로 import 하지 않고도 사용할 수 있다.
	String, Object, System, Thread ...
- import 문은 컴파일 시에 처리되므로 프로그램의 성능에 영향없음.
- java.util.* : util 안에 있는 모든 클래스를 나타냄. / java.* : java안에 있는 모든 클래스를 나타냄.

static import 문
- static 맴버를 사용할 때 클래스 이름을 생략할 수 있게 해준다.
	- 메서드 이름만 명시하고 사용 가능 
	- import static java.lang.System.out; > out.println();
	- 나중에 코딩할때 일일히 다 작성하면 길어지므로 짧게 하려고 사용함.



27강. 제어자(modifier)
- 클래스와 클래스의 멤버(멤버 변수, 메서드)에 부가적인 의미 부여.

- 접근 제어자 : public, protected, (default), private // 4개중 하나만 선택 가능.
- 그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp
- 하나의 대상에 여러 제어자를 같이 사용가능(단, 접근 제어자는 하나만 사용가능)

- static : 클래스의, 공통적인 // 객체 생성 없이 사용가능. but 인스턴스 변수와 메서드 사용 불가.
	> 변수, 메서드
	> 간단 초기화(cv), 복잡한 초기화(클래스 초기화 블럭), cv메서드
	
- final : 마지막의, 변경될 수 없는
	> 클래스 : 다른 클래스의 조상이 될 수 없음
	> 메서드 : 오버라이딩이 안됨.
	> 멤버변수, 지역변수 : 값을 변경할 수 없는 상수가 됨.

- abstract : 추상의, 미완성의
	> 추상 메서드 : 메서드 중에 {} 몸통이 없고 앞에 abstract 를 붙임.
	> 추상 클래스 : 추상 메서드를 갖고 있는 클래스. 
		> 미완성 설계도 > 인스턴스 생성 불가 > 객체 생성 불가.
		> 추상 클래스를 상속 받아서 완전한 클래스를 만들어야 객체생성가능.


28강. 접근 제어자(access modifier)
- private : 같은 클래스 내에서만 접근이 가능하다.
- (default) : 같은 패키지 내에서만 접근이 가능.
- protected : 같은 패키지 내에서 다른 패키지의 자손 클래스에서 접근 가능.
- public : 접근 제한이 전혀 없음.



29강. 캡슐화와 접근 제어자.
접근 제어자를 사용하는 이유?
	- 외부로부터 데이터를 보호하기 위해서.
	- 외부에서 직접 접근을 private으로 막고, 메서드로 간접 접근하게 만듬.
		- getter/setter 사용함 > 프로퍼티
	- 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서.

- 조건식을 따로 메서드로 빼서 boolean으로 생성해도 됨.
- 접근 제어자는 최대한 좁히는게 좋음.



30강. 다형성(polymorphism)
- 여러가지 형태를 가질 수 있는 능력.
- 조상 타입 참조변수(레퍼런스)로 자손 타입 객체(new Object)를 다루는 것. ==> 타입 불일치.
	- 자손 타입 참조변수와 조상 타입 객체는 컴파일 에러!!!!! #####

- 객체와 참조변수의 타입이 일치할 때와 일치하지 않을 때의 차이?
- 참조변수의 타입은 인스턴스 타입과 반드시 일치하지 않을 수 있다.
- 참조변수가 조상타입일때와 자손타입일 때의 차이는 참조변수로 사용할 수 있는 맴버의 개수가 달라짐.
- 자손 타입의 참조변수로 조상타입의 객체를 가리킬 수 없다.



31~32강. 참조변수의 형변환
- 사용할 수 있는 멤버의 갯수를 조절하는 것.
- 조상, 자손 관계의 참조변수는 서로 형변환 가능.
- 사용할 수 있는 멤버의 갯수가 늘었다 줄었다 함. > 레퍼런스의 멤버 기준으로 생각.



33강. instanceof 연산자
- 참조변수의 형변환 가능여부 확인에 사용. 가능하면 true 반환.
	> 앞선 참조변수의 형변환을 하기 위해선 instanceof 연산자를 반드시 꼭 확인하기!
- A instanceof B : B가 A의 조상 or 본인클래스인가? > true가 나온다면 A는 B로 형변환 가능하다.
- 참조변수의 형변환은 사용할 수 있는 멤버의 갯수를 조절하기 위해서 함.



34강. 매개변수의 다형성
- 참조형 매개변수는 메서드 호출 시, 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다.
- 장점 : 다형적 매개변수, 하나의 배열로 여러종류 객체 다루기.
- 메서드 하나로 여러 메서드를

































